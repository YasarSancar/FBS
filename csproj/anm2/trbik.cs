// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace gfl.anm2.fb.trbik
{

using global::System;
using global::System.Collections.Generic;
using global::FlatBuffers;

public struct Vector : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public Vector __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float X { get { return __p.bb.GetFloat(__p.bb_pos + 0); } }
  public float Y { get { return __p.bb.GetFloat(__p.bb_pos + 4); } }
  public float Z { get { return __p.bb.GetFloat(__p.bb_pos + 8); } }

  public static Offset<gfl.anm2.fb.trbik.Vector> CreateVector(FlatBufferBuilder builder, float X, float Y, float Z) {
    builder.Prep(4, 12);
    builder.PutFloat(Z);
    builder.PutFloat(Y);
    builder.PutFloat(X);
    return new Offset<gfl.anm2.fb.trbik.Vector>(builder.Offset);
  }
  public VectorT UnPack() {
    var _o = new VectorT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(VectorT _o) {
    _o.X = this.X;
    _o.Y = this.Y;
    _o.Z = this.Z;
  }
  public static Offset<gfl.anm2.fb.trbik.Vector> Pack(FlatBufferBuilder builder, VectorT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fb.trbik.Vector>);
    return CreateVector(
      builder,
      _o.X,
      _o.Y,
      _o.Z);
  }
};

public class VectorT
{
  [Newtonsoft.Json.JsonProperty("x")]
  public float X { get; set; }
  [Newtonsoft.Json.JsonProperty("y")]
  public float Y { get; set; }
  [Newtonsoft.Json.JsonProperty("z")]
  public float Z { get; set; }

  public VectorT() {
    this.X = 0.0f;
    this.Y = 0.0f;
    this.Z = 0.0f;
  }
}

public struct FootSolver : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static FootSolver GetRootAsFootSolver(ByteBuffer _bb) { return GetRootAsFootSolver(_bb, new FootSolver()); }
  public static FootSolver GetRootAsFootSolver(ByteBuffer _bb, FootSolver obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public FootSolver __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public bool Activation { get { int o = __p.__offset(4); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public float Factor { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public bool RootConstraintActivation { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public float RootConstraintRangeAxisYPositive { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float RootConstraintRangeAxisYNegative { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float RootConstraintRangeAxisZPositive { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float RootConstraintRangeAxisZNegative { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public int RootConstraintIterations { get { int o = __p.__offset(18); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public bool MiddleConstraintActivation { get { int o = __p.__offset(20); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public float MiddleConstraintRangePositive { get { int o = __p.__offset(22); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float MiddleConstraintRangeNegative { get { int o = __p.__offset(24); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public gfl.anm2.fb.trbik.Vector? PoleVector { get { int o = __p.__offset(26); return o != 0 ? (gfl.anm2.fb.trbik.Vector?)(new gfl.anm2.fb.trbik.Vector()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public float Twist { get { int o = __p.__offset(28); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<gfl.anm2.fb.trbik.FootSolver> CreateFootSolver(FlatBufferBuilder builder,
      bool activation = false,
      float factor = 0.0f,
      bool rootConstraintActivation = false,
      float rootConstraintRangeAxisY_Positive = 0.0f,
      float rootConstraintRangeAxisY_Negative = 0.0f,
      float rootConstraintRangeAxisZ_Positive = 0.0f,
      float rootConstraintRangeAxisZ_Negative = 0.0f,
      int rootConstraintIterations = 0,
      bool middleConstraintActivation = false,
      float middleConstraintRange_Positive = 0.0f,
      float middleConstraintRange_Negative = 0.0f,
      gfl.anm2.fb.trbik.VectorT poleVector = null,
      float twist = 0.0f) {
    builder.StartTable(13);
    FootSolver.AddTwist(builder, twist);
    FootSolver.AddPoleVector(builder, gfl.anm2.fb.trbik.Vector.Pack(builder, poleVector));
    FootSolver.AddMiddleConstraintRangeNegative(builder, middleConstraintRange_Negative);
    FootSolver.AddMiddleConstraintRangePositive(builder, middleConstraintRange_Positive);
    FootSolver.AddRootConstraintIterations(builder, rootConstraintIterations);
    FootSolver.AddRootConstraintRangeAxisZNegative(builder, rootConstraintRangeAxisZ_Negative);
    FootSolver.AddRootConstraintRangeAxisZPositive(builder, rootConstraintRangeAxisZ_Positive);
    FootSolver.AddRootConstraintRangeAxisYNegative(builder, rootConstraintRangeAxisY_Negative);
    FootSolver.AddRootConstraintRangeAxisYPositive(builder, rootConstraintRangeAxisY_Positive);
    FootSolver.AddFactor(builder, factor);
    FootSolver.AddMiddleConstraintActivation(builder, middleConstraintActivation);
    FootSolver.AddRootConstraintActivation(builder, rootConstraintActivation);
    FootSolver.AddActivation(builder, activation);
    return FootSolver.EndFootSolver(builder);
  }

  public static void StartFootSolver(FlatBufferBuilder builder) { builder.StartTable(13); }
  public static void AddActivation(FlatBufferBuilder builder, bool activation) { builder.AddBool(0, activation, false); }
  public static void AddFactor(FlatBufferBuilder builder, float factor) { builder.AddFloat(1, factor, 0.0f); }
  public static void AddRootConstraintActivation(FlatBufferBuilder builder, bool rootConstraintActivation) { builder.AddBool(2, rootConstraintActivation, false); }
  public static void AddRootConstraintRangeAxisYPositive(FlatBufferBuilder builder, float rootConstraintRangeAxisYPositive) { builder.AddFloat(3, rootConstraintRangeAxisYPositive, 0.0f); }
  public static void AddRootConstraintRangeAxisYNegative(FlatBufferBuilder builder, float rootConstraintRangeAxisYNegative) { builder.AddFloat(4, rootConstraintRangeAxisYNegative, 0.0f); }
  public static void AddRootConstraintRangeAxisZPositive(FlatBufferBuilder builder, float rootConstraintRangeAxisZPositive) { builder.AddFloat(5, rootConstraintRangeAxisZPositive, 0.0f); }
  public static void AddRootConstraintRangeAxisZNegative(FlatBufferBuilder builder, float rootConstraintRangeAxisZNegative) { builder.AddFloat(6, rootConstraintRangeAxisZNegative, 0.0f); }
  public static void AddRootConstraintIterations(FlatBufferBuilder builder, int rootConstraintIterations) { builder.AddInt(7, rootConstraintIterations, 0); }
  public static void AddMiddleConstraintActivation(FlatBufferBuilder builder, bool middleConstraintActivation) { builder.AddBool(8, middleConstraintActivation, false); }
  public static void AddMiddleConstraintRangePositive(FlatBufferBuilder builder, float middleConstraintRangePositive) { builder.AddFloat(9, middleConstraintRangePositive, 0.0f); }
  public static void AddMiddleConstraintRangeNegative(FlatBufferBuilder builder, float middleConstraintRangeNegative) { builder.AddFloat(10, middleConstraintRangeNegative, 0.0f); }
  public static void AddPoleVector(FlatBufferBuilder builder, Offset<gfl.anm2.fb.trbik.Vector> poleVectorOffset) { builder.AddStruct(11, poleVectorOffset.Value, 0); }
  public static void AddTwist(FlatBufferBuilder builder, float twist) { builder.AddFloat(12, twist, 0.0f); }
  public static Offset<gfl.anm2.fb.trbik.FootSolver> EndFootSolver(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fb.trbik.FootSolver>(o);
  }
  public FootSolverT UnPack() {
    var _o = new FootSolverT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(FootSolverT _o) {
    _o.Activation = this.Activation;
    _o.Factor = this.Factor;
    _o.RootConstraintActivation = this.RootConstraintActivation;
    _o.RootConstraintRangeAxisYPositive = this.RootConstraintRangeAxisYPositive;
    _o.RootConstraintRangeAxisYNegative = this.RootConstraintRangeAxisYNegative;
    _o.RootConstraintRangeAxisZPositive = this.RootConstraintRangeAxisZPositive;
    _o.RootConstraintRangeAxisZNegative = this.RootConstraintRangeAxisZNegative;
    _o.RootConstraintIterations = this.RootConstraintIterations;
    _o.MiddleConstraintActivation = this.MiddleConstraintActivation;
    _o.MiddleConstraintRangePositive = this.MiddleConstraintRangePositive;
    _o.MiddleConstraintRangeNegative = this.MiddleConstraintRangeNegative;
    _o.PoleVector = this.PoleVector.HasValue ? this.PoleVector.Value.UnPack() : null;
    _o.Twist = this.Twist;
  }
  public static Offset<gfl.anm2.fb.trbik.FootSolver> Pack(FlatBufferBuilder builder, FootSolverT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fb.trbik.FootSolver>);
    return CreateFootSolver(
      builder,
      _o.Activation,
      _o.Factor,
      _o.RootConstraintActivation,
      _o.RootConstraintRangeAxisYPositive,
      _o.RootConstraintRangeAxisYNegative,
      _o.RootConstraintRangeAxisZPositive,
      _o.RootConstraintRangeAxisZNegative,
      _o.RootConstraintIterations,
      _o.MiddleConstraintActivation,
      _o.MiddleConstraintRangePositive,
      _o.MiddleConstraintRangeNegative,
      _o.PoleVector,
      _o.Twist);
  }
};

public class FootSolverT
{
  [Newtonsoft.Json.JsonProperty("activation")]
  public bool Activation { get; set; }
  [Newtonsoft.Json.JsonProperty("factor")]
  public float Factor { get; set; }
  [Newtonsoft.Json.JsonProperty("rootConstraintActivation")]
  public bool RootConstraintActivation { get; set; }
  [Newtonsoft.Json.JsonProperty("rootConstraintRangeAxisY_Positive")]
  public float RootConstraintRangeAxisYPositive { get; set; }
  [Newtonsoft.Json.JsonProperty("rootConstraintRangeAxisY_Negative")]
  public float RootConstraintRangeAxisYNegative { get; set; }
  [Newtonsoft.Json.JsonProperty("rootConstraintRangeAxisZ_Positive")]
  public float RootConstraintRangeAxisZPositive { get; set; }
  [Newtonsoft.Json.JsonProperty("rootConstraintRangeAxisZ_Negative")]
  public float RootConstraintRangeAxisZNegative { get; set; }
  [Newtonsoft.Json.JsonProperty("rootConstraintIterations")]
  public int RootConstraintIterations { get; set; }
  [Newtonsoft.Json.JsonProperty("middleConstraintActivation")]
  public bool MiddleConstraintActivation { get; set; }
  [Newtonsoft.Json.JsonProperty("middleConstraintRange_Positive")]
  public float MiddleConstraintRangePositive { get; set; }
  [Newtonsoft.Json.JsonProperty("middleConstraintRange_Negative")]
  public float MiddleConstraintRangeNegative { get; set; }
  [Newtonsoft.Json.JsonProperty("poleVector")]
  public gfl.anm2.fb.trbik.VectorT PoleVector { get; set; }
  [Newtonsoft.Json.JsonProperty("twist")]
  public float Twist { get; set; }

  public FootSolverT() {
    this.Activation = false;
    this.Factor = 0.0f;
    this.RootConstraintActivation = false;
    this.RootConstraintRangeAxisYPositive = 0.0f;
    this.RootConstraintRangeAxisYNegative = 0.0f;
    this.RootConstraintRangeAxisZPositive = 0.0f;
    this.RootConstraintRangeAxisZNegative = 0.0f;
    this.RootConstraintIterations = 0;
    this.MiddleConstraintActivation = false;
    this.MiddleConstraintRangePositive = 0.0f;
    this.MiddleConstraintRangeNegative = 0.0f;
    this.PoleVector = new gfl.anm2.fb.trbik.VectorT();
    this.Twist = 0.0f;
  }
}

public struct ToeSolver : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static ToeSolver GetRootAsToeSolver(ByteBuffer _bb) { return GetRootAsToeSolver(_bb, new ToeSolver()); }
  public static ToeSolver GetRootAsToeSolver(ByteBuffer _bb, ToeSolver obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ToeSolver __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public bool Activation { get { int o = __p.__offset(4); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public float Factor { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public bool ConstraintActivation { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public gfl.anm2.fb.trbik.Vector? LocalForward { get { int o = __p.__offset(10); return o != 0 ? (gfl.anm2.fb.trbik.Vector?)(new gfl.anm2.fb.trbik.Vector()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public gfl.anm2.fb.trbik.Vector? LocalUp { get { int o = __p.__offset(12); return o != 0 ? (gfl.anm2.fb.trbik.Vector?)(new gfl.anm2.fb.trbik.Vector()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public float FwdPositive { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float FwdNegative { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float SidePositive { get { int o = __p.__offset(18); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float SideNegative { get { int o = __p.__offset(20); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<gfl.anm2.fb.trbik.ToeSolver> CreateToeSolver(FlatBufferBuilder builder,
      bool activation = false,
      float factor = 0.0f,
      bool constraintActivation = false,
      gfl.anm2.fb.trbik.VectorT localForward = null,
      gfl.anm2.fb.trbik.VectorT localUp = null,
      float fwd_Positive = 0.0f,
      float fwd_Negative = 0.0f,
      float side_Positive = 0.0f,
      float side_Negative = 0.0f) {
    builder.StartTable(9);
    ToeSolver.AddSideNegative(builder, side_Negative);
    ToeSolver.AddSidePositive(builder, side_Positive);
    ToeSolver.AddFwdNegative(builder, fwd_Negative);
    ToeSolver.AddFwdPositive(builder, fwd_Positive);
    ToeSolver.AddLocalUp(builder, gfl.anm2.fb.trbik.Vector.Pack(builder, localUp));
    ToeSolver.AddLocalForward(builder, gfl.anm2.fb.trbik.Vector.Pack(builder, localForward));
    ToeSolver.AddFactor(builder, factor);
    ToeSolver.AddConstraintActivation(builder, constraintActivation);
    ToeSolver.AddActivation(builder, activation);
    return ToeSolver.EndToeSolver(builder);
  }

  public static void StartToeSolver(FlatBufferBuilder builder) { builder.StartTable(9); }
  public static void AddActivation(FlatBufferBuilder builder, bool activation) { builder.AddBool(0, activation, false); }
  public static void AddFactor(FlatBufferBuilder builder, float factor) { builder.AddFloat(1, factor, 0.0f); }
  public static void AddConstraintActivation(FlatBufferBuilder builder, bool constraintActivation) { builder.AddBool(2, constraintActivation, false); }
  public static void AddLocalForward(FlatBufferBuilder builder, Offset<gfl.anm2.fb.trbik.Vector> localForwardOffset) { builder.AddStruct(3, localForwardOffset.Value, 0); }
  public static void AddLocalUp(FlatBufferBuilder builder, Offset<gfl.anm2.fb.trbik.Vector> localUpOffset) { builder.AddStruct(4, localUpOffset.Value, 0); }
  public static void AddFwdPositive(FlatBufferBuilder builder, float fwdPositive) { builder.AddFloat(5, fwdPositive, 0.0f); }
  public static void AddFwdNegative(FlatBufferBuilder builder, float fwdNegative) { builder.AddFloat(6, fwdNegative, 0.0f); }
  public static void AddSidePositive(FlatBufferBuilder builder, float sidePositive) { builder.AddFloat(7, sidePositive, 0.0f); }
  public static void AddSideNegative(FlatBufferBuilder builder, float sideNegative) { builder.AddFloat(8, sideNegative, 0.0f); }
  public static Offset<gfl.anm2.fb.trbik.ToeSolver> EndToeSolver(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fb.trbik.ToeSolver>(o);
  }
  public ToeSolverT UnPack() {
    var _o = new ToeSolverT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(ToeSolverT _o) {
    _o.Activation = this.Activation;
    _o.Factor = this.Factor;
    _o.ConstraintActivation = this.ConstraintActivation;
    _o.LocalForward = this.LocalForward.HasValue ? this.LocalForward.Value.UnPack() : null;
    _o.LocalUp = this.LocalUp.HasValue ? this.LocalUp.Value.UnPack() : null;
    _o.FwdPositive = this.FwdPositive;
    _o.FwdNegative = this.FwdNegative;
    _o.SidePositive = this.SidePositive;
    _o.SideNegative = this.SideNegative;
  }
  public static Offset<gfl.anm2.fb.trbik.ToeSolver> Pack(FlatBufferBuilder builder, ToeSolverT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fb.trbik.ToeSolver>);
    return CreateToeSolver(
      builder,
      _o.Activation,
      _o.Factor,
      _o.ConstraintActivation,
      _o.LocalForward,
      _o.LocalUp,
      _o.FwdPositive,
      _o.FwdNegative,
      _o.SidePositive,
      _o.SideNegative);
  }
};

public class ToeSolverT
{
  [Newtonsoft.Json.JsonProperty("activation")]
  public bool Activation { get; set; }
  [Newtonsoft.Json.JsonProperty("factor")]
  public float Factor { get; set; }
  [Newtonsoft.Json.JsonProperty("constraintActivation")]
  public bool ConstraintActivation { get; set; }
  [Newtonsoft.Json.JsonProperty("localForward")]
  public gfl.anm2.fb.trbik.VectorT LocalForward { get; set; }
  [Newtonsoft.Json.JsonProperty("localUp")]
  public gfl.anm2.fb.trbik.VectorT LocalUp { get; set; }
  [Newtonsoft.Json.JsonProperty("fwd_Positive")]
  public float FwdPositive { get; set; }
  [Newtonsoft.Json.JsonProperty("fwd_Negative")]
  public float FwdNegative { get; set; }
  [Newtonsoft.Json.JsonProperty("side_Positive")]
  public float SidePositive { get; set; }
  [Newtonsoft.Json.JsonProperty("side_Negative")]
  public float SideNegative { get; set; }

  public ToeSolverT() {
    this.Activation = false;
    this.Factor = 0.0f;
    this.ConstraintActivation = false;
    this.LocalForward = new gfl.anm2.fb.trbik.VectorT();
    this.LocalUp = new gfl.anm2.fb.trbik.VectorT();
    this.FwdPositive = 0.0f;
    this.FwdNegative = 0.0f;
    this.SidePositive = 0.0f;
    this.SideNegative = 0.0f;
  }
}

public struct FootControl : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static FootControl GetRootAsFootControl(ByteBuffer _bb) { return GetRootAsFootControl(_bb, new FootControl()); }
  public static FootControl GetRootAsFootControl(ByteBuffer _bb, FootControl obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public FootControl __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Name { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(4); }
  public bool Activation { get { int o = __p.__offset(6); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public float Factor { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public string RootJointName { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetRootJointNameBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetRootJointNameBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetRootJointNameArray() { return __p.__vector_as_array<byte>(10); }
  public string MidJointName { get { int o = __p.__offset(12); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMidJointNameBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetMidJointNameBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetMidJointNameArray() { return __p.__vector_as_array<byte>(12); }
  public string TipJointName { get { int o = __p.__offset(14); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTipJointNameBytes() { return __p.__vector_as_span<byte>(14, 1); }
#else
  public ArraySegment<byte>? GetTipJointNameBytes() { return __p.__vector_as_arraysegment(14); }
#endif
  public byte[] GetTipJointNameArray() { return __p.__vector_as_array<byte>(14); }
  public string AnkleJointName { get { int o = __p.__offset(16); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAnkleJointNameBytes() { return __p.__vector_as_span<byte>(16, 1); }
#else
  public ArraySegment<byte>? GetAnkleJointNameBytes() { return __p.__vector_as_arraysegment(16); }
#endif
  public byte[] GetAnkleJointNameArray() { return __p.__vector_as_array<byte>(16); }
  public gfl.anm2.fb.trbik.ToeSolver? ToeSolver { get { int o = __p.__offset(18); return o != 0 ? (gfl.anm2.fb.trbik.ToeSolver?)(new gfl.anm2.fb.trbik.ToeSolver()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public gfl.anm2.fb.trbik.FootSolver? FootSolver { get { int o = __p.__offset(20); return o != 0 ? (gfl.anm2.fb.trbik.FootSolver?)(new gfl.anm2.fb.trbik.FootSolver()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public string ToeJointName { get { int o = __p.__offset(22); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetToeJointNameBytes() { return __p.__vector_as_span<byte>(22, 1); }
#else
  public ArraySegment<byte>? GetToeJointNameBytes() { return __p.__vector_as_arraysegment(22); }
#endif
  public byte[] GetToeJointNameArray() { return __p.__vector_as_array<byte>(22); }

  public static Offset<gfl.anm2.fb.trbik.FootControl> CreateFootControl(FlatBufferBuilder builder,
      StringOffset nameOffset = default(StringOffset),
      bool activation = false,
      float factor = 0.0f,
      StringOffset rootJointNameOffset = default(StringOffset),
      StringOffset midJointNameOffset = default(StringOffset),
      StringOffset tipJointNameOffset = default(StringOffset),
      StringOffset ankleJointNameOffset = default(StringOffset),
      Offset<gfl.anm2.fb.trbik.ToeSolver> toeSolverOffset = default(Offset<gfl.anm2.fb.trbik.ToeSolver>),
      Offset<gfl.anm2.fb.trbik.FootSolver> footSolverOffset = default(Offset<gfl.anm2.fb.trbik.FootSolver>),
      StringOffset toeJointNameOffset = default(StringOffset)) {
    builder.StartTable(10);
    FootControl.AddToeJointName(builder, toeJointNameOffset);
    FootControl.AddFootSolver(builder, footSolverOffset);
    FootControl.AddToeSolver(builder, toeSolverOffset);
    FootControl.AddAnkleJointName(builder, ankleJointNameOffset);
    FootControl.AddTipJointName(builder, tipJointNameOffset);
    FootControl.AddMidJointName(builder, midJointNameOffset);
    FootControl.AddRootJointName(builder, rootJointNameOffset);
    FootControl.AddFactor(builder, factor);
    FootControl.AddName(builder, nameOffset);
    FootControl.AddActivation(builder, activation);
    return FootControl.EndFootControl(builder);
  }

  public static void StartFootControl(FlatBufferBuilder builder) { builder.StartTable(10); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(0, nameOffset.Value, 0); }
  public static void AddActivation(FlatBufferBuilder builder, bool activation) { builder.AddBool(1, activation, false); }
  public static void AddFactor(FlatBufferBuilder builder, float factor) { builder.AddFloat(2, factor, 0.0f); }
  public static void AddRootJointName(FlatBufferBuilder builder, StringOffset rootJointNameOffset) { builder.AddOffset(3, rootJointNameOffset.Value, 0); }
  public static void AddMidJointName(FlatBufferBuilder builder, StringOffset midJointNameOffset) { builder.AddOffset(4, midJointNameOffset.Value, 0); }
  public static void AddTipJointName(FlatBufferBuilder builder, StringOffset tipJointNameOffset) { builder.AddOffset(5, tipJointNameOffset.Value, 0); }
  public static void AddAnkleJointName(FlatBufferBuilder builder, StringOffset ankleJointNameOffset) { builder.AddOffset(6, ankleJointNameOffset.Value, 0); }
  public static void AddToeSolver(FlatBufferBuilder builder, Offset<gfl.anm2.fb.trbik.ToeSolver> toeSolverOffset) { builder.AddOffset(7, toeSolverOffset.Value, 0); }
  public static void AddFootSolver(FlatBufferBuilder builder, Offset<gfl.anm2.fb.trbik.FootSolver> footSolverOffset) { builder.AddOffset(8, footSolverOffset.Value, 0); }
  public static void AddToeJointName(FlatBufferBuilder builder, StringOffset toeJointNameOffset) { builder.AddOffset(9, toeJointNameOffset.Value, 0); }
  public static Offset<gfl.anm2.fb.trbik.FootControl> EndFootControl(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fb.trbik.FootControl>(o);
  }
  public FootControlT UnPack() {
    var _o = new FootControlT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(FootControlT _o) {
    _o.Name = this.Name;
    _o.Activation = this.Activation;
    _o.Factor = this.Factor;
    _o.RootJointName = this.RootJointName;
    _o.MidJointName = this.MidJointName;
    _o.TipJointName = this.TipJointName;
    _o.AnkleJointName = this.AnkleJointName;
    _o.ToeSolver = this.ToeSolver.HasValue ? this.ToeSolver.Value.UnPack() : null;
    _o.FootSolver = this.FootSolver.HasValue ? this.FootSolver.Value.UnPack() : null;
    _o.ToeJointName = this.ToeJointName;
  }
  public static Offset<gfl.anm2.fb.trbik.FootControl> Pack(FlatBufferBuilder builder, FootControlT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fb.trbik.FootControl>);
    var _name = _o.Name == null ? default(StringOffset) : builder.CreateString(_o.Name);
    var _rootJointName = _o.RootJointName == null ? default(StringOffset) : builder.CreateString(_o.RootJointName);
    var _midJointName = _o.MidJointName == null ? default(StringOffset) : builder.CreateString(_o.MidJointName);
    var _tipJointName = _o.TipJointName == null ? default(StringOffset) : builder.CreateString(_o.TipJointName);
    var _ankleJointName = _o.AnkleJointName == null ? default(StringOffset) : builder.CreateString(_o.AnkleJointName);
    var _toeSolver = _o.ToeSolver == null ? default(Offset<gfl.anm2.fb.trbik.ToeSolver>) : gfl.anm2.fb.trbik.ToeSolver.Pack(builder, _o.ToeSolver);
    var _footSolver = _o.FootSolver == null ? default(Offset<gfl.anm2.fb.trbik.FootSolver>) : gfl.anm2.fb.trbik.FootSolver.Pack(builder, _o.FootSolver);
    var _toeJointName = _o.ToeJointName == null ? default(StringOffset) : builder.CreateString(_o.ToeJointName);
    return CreateFootControl(
      builder,
      _name,
      _o.Activation,
      _o.Factor,
      _rootJointName,
      _midJointName,
      _tipJointName,
      _ankleJointName,
      _toeSolver,
      _footSolver,
      _toeJointName);
  }
};

public class FootControlT
{
  [Newtonsoft.Json.JsonProperty("name")]
  public string Name { get; set; }
  [Newtonsoft.Json.JsonProperty("activation")]
  public bool Activation { get; set; }
  [Newtonsoft.Json.JsonProperty("factor")]
  public float Factor { get; set; }
  [Newtonsoft.Json.JsonProperty("rootJointName")]
  public string RootJointName { get; set; }
  [Newtonsoft.Json.JsonProperty("midJointName")]
  public string MidJointName { get; set; }
  [Newtonsoft.Json.JsonProperty("tipJointName")]
  public string TipJointName { get; set; }
  [Newtonsoft.Json.JsonProperty("ankleJointName")]
  public string AnkleJointName { get; set; }
  [Newtonsoft.Json.JsonProperty("toeSolver")]
  public gfl.anm2.fb.trbik.ToeSolverT ToeSolver { get; set; }
  [Newtonsoft.Json.JsonProperty("footSolver")]
  public gfl.anm2.fb.trbik.FootSolverT FootSolver { get; set; }
  [Newtonsoft.Json.JsonProperty("toeJointName")]
  public string ToeJointName { get; set; }

  public FootControlT() {
    this.Name = null;
    this.Activation = false;
    this.Factor = 0.0f;
    this.RootJointName = null;
    this.MidJointName = null;
    this.TipJointName = null;
    this.AnkleJointName = null;
    this.ToeSolver = null;
    this.FootSolver = null;
    this.ToeJointName = null;
  }
}

public struct OffsetSolver : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static OffsetSolver GetRootAsOffsetSolver(ByteBuffer _bb) { return GetRootAsOffsetSolver(_bb, new OffsetSolver()); }
  public static OffsetSolver GetRootAsOffsetSolver(ByteBuffer _bb, OffsetSolver obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public OffsetSolver __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string JointName { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetJointNameBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetJointNameBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetJointNameArray() { return __p.__vector_as_array<byte>(4); }
  public bool Activation { get { int o = __p.__offset(6); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public float Factor { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<gfl.anm2.fb.trbik.OffsetSolver> CreateOffsetSolver(FlatBufferBuilder builder,
      StringOffset jointNameOffset = default(StringOffset),
      bool activation = false,
      float factor = 0.0f) {
    builder.StartTable(3);
    OffsetSolver.AddFactor(builder, factor);
    OffsetSolver.AddJointName(builder, jointNameOffset);
    OffsetSolver.AddActivation(builder, activation);
    return OffsetSolver.EndOffsetSolver(builder);
  }

  public static void StartOffsetSolver(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddJointName(FlatBufferBuilder builder, StringOffset jointNameOffset) { builder.AddOffset(0, jointNameOffset.Value, 0); }
  public static void AddActivation(FlatBufferBuilder builder, bool activation) { builder.AddBool(1, activation, false); }
  public static void AddFactor(FlatBufferBuilder builder, float factor) { builder.AddFloat(2, factor, 0.0f); }
  public static Offset<gfl.anm2.fb.trbik.OffsetSolver> EndOffsetSolver(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fb.trbik.OffsetSolver>(o);
  }
  public OffsetSolverT UnPack() {
    var _o = new OffsetSolverT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(OffsetSolverT _o) {
    _o.JointName = this.JointName;
    _o.Activation = this.Activation;
    _o.Factor = this.Factor;
  }
  public static Offset<gfl.anm2.fb.trbik.OffsetSolver> Pack(FlatBufferBuilder builder, OffsetSolverT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fb.trbik.OffsetSolver>);
    var _jointName = _o.JointName == null ? default(StringOffset) : builder.CreateString(_o.JointName);
    return CreateOffsetSolver(
      builder,
      _jointName,
      _o.Activation,
      _o.Factor);
  }
};

public class OffsetSolverT
{
  [Newtonsoft.Json.JsonProperty("jointName")]
  public string JointName { get; set; }
  [Newtonsoft.Json.JsonProperty("activation")]
  public bool Activation { get; set; }
  [Newtonsoft.Json.JsonProperty("factor")]
  public float Factor { get; set; }

  public OffsetSolverT() {
    this.JointName = null;
    this.Activation = false;
    this.Factor = 0.0f;
  }
}

public struct Root : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static Root GetRootAsRoot(ByteBuffer _bb) { return GetRootAsRoot(_bb, new Root()); }
  public static Root GetRootAsRoot(ByteBuffer _bb, Root obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool RootBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "TRBI"); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Root __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public gfl.anm2.fb.trbik.OffsetSolver? OffsetSolver { get { int o = __p.__offset(4); return o != 0 ? (gfl.anm2.fb.trbik.OffsetSolver?)(new gfl.anm2.fb.trbik.OffsetSolver()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public gfl.anm2.fb.trbik.FootControl? FootControls(int j) { int o = __p.__offset(6); return o != 0 ? (gfl.anm2.fb.trbik.FootControl?)(new gfl.anm2.fb.trbik.FootControl()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int FootControlsLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
  public bool IsUseAdditionalParameterWeights { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public float LimitFootHeightDifference { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.25f; } }
  public float ToeEndOffset { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public bool IsLocomotion { get { int o = __p.__offset(14); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public float RangeWeight { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float MaxGroundAngle { get { int o = __p.__offset(18); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)90.0f; } }
  public float MaxHeight { get { int o = __p.__offset(20); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float GroundWeight { get { int o = __p.__offset(22); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)1.0f; } }

  public static Offset<gfl.anm2.fb.trbik.Root> CreateRoot(FlatBufferBuilder builder,
      Offset<gfl.anm2.fb.trbik.OffsetSolver> offsetSolverOffset = default(Offset<gfl.anm2.fb.trbik.OffsetSolver>),
      VectorOffset footControlsOffset = default(VectorOffset),
      bool isUseAdditionalParameterWeights = false,
      float limitFootHeightDifference = 0.25f,
      float toeEndOffset = 0.0f,
      bool isLocomotion = false,
      float rangeWeight = 0.0f,
      float maxGroundAngle = 90.0f,
      float maxHeight = 0.0f,
      float groundWeight = 1.0f) {
    builder.StartTable(10);
    Root.AddGroundWeight(builder, groundWeight);
    Root.AddMaxHeight(builder, maxHeight);
    Root.AddMaxGroundAngle(builder, maxGroundAngle);
    Root.AddRangeWeight(builder, rangeWeight);
    Root.AddToeEndOffset(builder, toeEndOffset);
    Root.AddLimitFootHeightDifference(builder, limitFootHeightDifference);
    Root.AddFootControls(builder, footControlsOffset);
    Root.AddOffsetSolver(builder, offsetSolverOffset);
    Root.AddIsLocomotion(builder, isLocomotion);
    Root.AddIsUseAdditionalParameterWeights(builder, isUseAdditionalParameterWeights);
    return Root.EndRoot(builder);
  }

  public static void StartRoot(FlatBufferBuilder builder) { builder.StartTable(10); }
  public static void AddOffsetSolver(FlatBufferBuilder builder, Offset<gfl.anm2.fb.trbik.OffsetSolver> offsetSolverOffset) { builder.AddOffset(0, offsetSolverOffset.Value, 0); }
  public static void AddFootControls(FlatBufferBuilder builder, VectorOffset footControlsOffset) { builder.AddOffset(1, footControlsOffset.Value, 0); }
  public static VectorOffset CreateFootControlsVector(FlatBufferBuilder builder, Offset<gfl.anm2.fb.trbik.FootControl>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateFootControlsVectorBlock(FlatBufferBuilder builder, Offset<gfl.anm2.fb.trbik.FootControl>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartFootControlsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddIsUseAdditionalParameterWeights(FlatBufferBuilder builder, bool isUseAdditionalParameterWeights) { builder.AddBool(2, isUseAdditionalParameterWeights, false); }
  public static void AddLimitFootHeightDifference(FlatBufferBuilder builder, float limitFootHeightDifference) { builder.AddFloat(3, limitFootHeightDifference, 0.25f); }
  public static void AddToeEndOffset(FlatBufferBuilder builder, float toeEndOffset) { builder.AddFloat(4, toeEndOffset, 0.0f); }
  public static void AddIsLocomotion(FlatBufferBuilder builder, bool isLocomotion) { builder.AddBool(5, isLocomotion, false); }
  public static void AddRangeWeight(FlatBufferBuilder builder, float rangeWeight) { builder.AddFloat(6, rangeWeight, 0.0f); }
  public static void AddMaxGroundAngle(FlatBufferBuilder builder, float maxGroundAngle) { builder.AddFloat(7, maxGroundAngle, 90.0f); }
  public static void AddMaxHeight(FlatBufferBuilder builder, float maxHeight) { builder.AddFloat(8, maxHeight, 0.0f); }
  public static void AddGroundWeight(FlatBufferBuilder builder, float groundWeight) { builder.AddFloat(9, groundWeight, 1.0f); }
  public static Offset<gfl.anm2.fb.trbik.Root> EndRoot(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fb.trbik.Root>(o);
  }
  public static void FinishRootBuffer(FlatBufferBuilder builder, Offset<gfl.anm2.fb.trbik.Root> offset) { builder.Finish(offset.Value, "TRBI"); }
  public static void FinishSizePrefixedRootBuffer(FlatBufferBuilder builder, Offset<gfl.anm2.fb.trbik.Root> offset) { builder.FinishSizePrefixed(offset.Value, "TRBI"); }
  public RootT UnPack() {
    var _o = new RootT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(RootT _o) {
    _o.OffsetSolver = this.OffsetSolver.HasValue ? this.OffsetSolver.Value.UnPack() : null;
    _o.FootControls = new List<gfl.anm2.fb.trbik.FootControlT>();
    for (var _j = 0; _j < this.FootControlsLength; ++_j) {_o.FootControls.Add(this.FootControls(_j).HasValue ? this.FootControls(_j).Value.UnPack() : null);}
    _o.IsUseAdditionalParameterWeights = this.IsUseAdditionalParameterWeights;
    _o.LimitFootHeightDifference = this.LimitFootHeightDifference;
    _o.ToeEndOffset = this.ToeEndOffset;
    _o.IsLocomotion = this.IsLocomotion;
    _o.RangeWeight = this.RangeWeight;
    _o.MaxGroundAngle = this.MaxGroundAngle;
    _o.MaxHeight = this.MaxHeight;
    _o.GroundWeight = this.GroundWeight;
  }
  public static Offset<gfl.anm2.fb.trbik.Root> Pack(FlatBufferBuilder builder, RootT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fb.trbik.Root>);
    var _offsetSolver = _o.OffsetSolver == null ? default(Offset<gfl.anm2.fb.trbik.OffsetSolver>) : gfl.anm2.fb.trbik.OffsetSolver.Pack(builder, _o.OffsetSolver);
    var _footControls = default(VectorOffset);
    if (_o.FootControls != null) {
      var __footControls = new Offset<gfl.anm2.fb.trbik.FootControl>[_o.FootControls.Count];
      for (var _j = 0; _j < __footControls.Length; ++_j) { __footControls[_j] = gfl.anm2.fb.trbik.FootControl.Pack(builder, _o.FootControls[_j]); }
      _footControls = CreateFootControlsVector(builder, __footControls);
    }
    return CreateRoot(
      builder,
      _offsetSolver,
      _footControls,
      _o.IsUseAdditionalParameterWeights,
      _o.LimitFootHeightDifference,
      _o.ToeEndOffset,
      _o.IsLocomotion,
      _o.RangeWeight,
      _o.MaxGroundAngle,
      _o.MaxHeight,
      _o.GroundWeight);
  }
};

public class RootT
{
  [Newtonsoft.Json.JsonProperty("offsetSolver")]
  public gfl.anm2.fb.trbik.OffsetSolverT OffsetSolver { get; set; }
  [Newtonsoft.Json.JsonProperty("footControls")]
  public List<gfl.anm2.fb.trbik.FootControlT> FootControls { get; set; }
  [Newtonsoft.Json.JsonProperty("isUseAdditionalParameterWeights")]
  public bool IsUseAdditionalParameterWeights { get; set; }
  [Newtonsoft.Json.JsonProperty("limitFootHeightDifference")]
  public float LimitFootHeightDifference { get; set; }
  [Newtonsoft.Json.JsonProperty("toeEndOffset")]
  public float ToeEndOffset { get; set; }
  [Newtonsoft.Json.JsonProperty("isLocomotion")]
  public bool IsLocomotion { get; set; }
  [Newtonsoft.Json.JsonProperty("rangeWeight")]
  public float RangeWeight { get; set; }
  [Newtonsoft.Json.JsonProperty("maxGroundAngle")]
  public float MaxGroundAngle { get; set; }
  [Newtonsoft.Json.JsonProperty("maxHeight")]
  public float MaxHeight { get; set; }
  [Newtonsoft.Json.JsonProperty("groundWeight")]
  public float GroundWeight { get; set; }

  public RootT() {
    this.OffsetSolver = null;
    this.FootControls = null;
    this.IsUseAdditionalParameterWeights = false;
    this.LimitFootHeightDifference = 0.25f;
    this.ToeEndOffset = 0.0f;
    this.IsLocomotion = false;
    this.RangeWeight = 0.0f;
    this.MaxGroundAngle = 90.0f;
    this.MaxHeight = 0.0f;
    this.GroundWeight = 1.0f;
  }

  public static RootT DeserializeFromJson(string jsonText) {
    return Newtonsoft.Json.JsonConvert.DeserializeObject<RootT>(jsonText);
  }
  public string SerializeToJson() {
    return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
  }
  public static RootT DeserializeFromBinary(byte[] fbBuffer) {
    return Root.GetRootAsRoot(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    Root.FinishRootBuffer(fbb, Root.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


}
