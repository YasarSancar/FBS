// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace gfl.anm2.fb
{

using global::System;
using global::System.Collections.Generic;
using global::FlatBuffers;

[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
public enum UpAxisType : uint
{
  ZeroXPlusZMinusY = 0,
  ZeroXMinusZPlusY = 1,
  PlusZZeroYMinusX = 2,
  MinusZZeroYPlusX = 3,
  PlusYMinusXZeroZ = 4,
  MinusYPlusXZeroZ = 5,
};

[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
public enum InterpolationType : uint
{
  Linear = 0,
  EaseInOutQuad = 1,
  EaseInOutCubic = 2,
  EaseInOutQuart = 3,
  EaseInOutQuint = 4,
  EaseInOutSine = 5,
};

[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
public enum LookAtType : uint
{
  InterpolatedPosition = 0,
  AngleSpeed = 1,
};

public struct LookAtGroup : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static LookAtGroup GetRootAsLookAtGroup(ByteBuffer _bb) { return GetRootAsLookAtGroup(_bb, new LookAtGroup()); }
  public static LookAtGroup GetRootAsLookAtGroup(ByteBuffer _bb, LookAtGroup obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public LookAtGroup __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string ControlJointName { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetControlJointNameBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetControlJointNameBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetControlJointNameArray() { return __p.__vector_as_array<byte>(4); }
  public gfl.anm2.fb.Vector3? LookAtAxis { get { int o = __p.__offset(6); return o != 0 ? (gfl.anm2.fb.Vector3?)(new gfl.anm2.fb.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public gfl.anm2.fb.Vector3? LookUpAxis { get { int o = __p.__offset(8); return o != 0 ? (gfl.anm2.fb.Vector3?)(new gfl.anm2.fb.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public gfl.anm2.fb.UpAxisType UpAxisType { get { int o = __p.__offset(10); return o != 0 ? (gfl.anm2.fb.UpAxisType)__p.bb.GetUint(o + __p.bb_pos) : gfl.anm2.fb.UpAxisType.ZeroXPlusZMinusY; } }
  public float LeftClampInDegrees { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float RightClampInDegrees { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float UpClampInDegrees { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float DownClampInDegrees { get { int o = __p.__offset(18); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float HorizontalClampBlendRange { get { int o = __p.__offset(20); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float VerticalClampBlendRange { get { int o = __p.__offset(22); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float InterpolationTime { get { int o = __p.__offset(24); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public gfl.anm2.fb.InterpolationType InterpolationType { get { int o = __p.__offset(26); return o != 0 ? (gfl.anm2.fb.InterpolationType)__p.bb.GetUint(o + __p.bb_pos) : gfl.anm2.fb.InterpolationType.Linear; } }
  public bool IsMaterialLookAt { get { int o = __p.__offset(28); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public string MeshName { get { int o = __p.__offset(30); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMeshNameBytes() { return __p.__vector_as_span<byte>(30, 1); }
#else
  public ArraySegment<byte>? GetMeshNameBytes() { return __p.__vector_as_arraysegment(30); }
#endif
  public byte[] GetMeshNameArray() { return __p.__vector_as_array<byte>(30); }
  public string MaterialName { get { int o = __p.__offset(32); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMaterialNameBytes() { return __p.__vector_as_span<byte>(32, 1); }
#else
  public ArraySegment<byte>? GetMaterialNameBytes() { return __p.__vector_as_arraysegment(32); }
#endif
  public byte[] GetMaterialNameArray() { return __p.__vector_as_array<byte>(32); }
  public gfl.anm2.fb.Vector3? JointOffset { get { int o = __p.__offset(34); return o != 0 ? (gfl.anm2.fb.Vector3?)(new gfl.anm2.fb.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public bool IsUseInterpolationRotations { get { int o = __p.__offset(36); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public gfl.anm2.fb.Vector3? InterpolationPointValues(int j) { int o = __p.__offset(38); return o != 0 ? (gfl.anm2.fb.Vector3?)(new gfl.anm2.fb.Vector3()).__assign(__p.__vector(o) + j * 12, __p.bb) : null; }
  public int InterpolationPointValuesLength { get { int o = __p.__offset(38); return o != 0 ? __p.__vector_len(o) : 0; } }
  public bool IsUseInterpolationTranslations { get { int o = __p.__offset(40); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public gfl.anm2.fb.Vector3? InterpolationTranslationValues(int j) { int o = __p.__offset(42); return o != 0 ? (gfl.anm2.fb.Vector3?)(new gfl.anm2.fb.Vector3()).__assign(__p.__vector(o) + j * 12, __p.bb) : null; }
  public int InterpolationTranslationValuesLength { get { int o = __p.__offset(42); return o != 0 ? __p.__vector_len(o) : 0; } }
  public float RotSpeedPerSecond { get { int o = __p.__offset(44); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public string MaterialUVUniformNames(int j) { int o = __p.__offset(46); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int MaterialUVUniformNamesLength { get { int o = __p.__offset(46); return o != 0 ? __p.__vector_len(o) : 0; } }
  public float RotSpeedEaseTime { get { int o = __p.__offset(48); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float FixedLookAtTime { get { int o = __p.__offset(50); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float FixedLookAtAreaInDegrees { get { int o = __p.__offset(52); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float FixedLookAtReleaseAreaInDegrees { get { int o = __p.__offset(54); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public int ChannelID { get { int o = __p.__offset(56); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public float RotationWeights(int j) { int o = __p.__offset(58); return o != 0 ? __p.bb.GetFloat(__p.__vector(o) + j * 4) : (float)0; }
  public int RotationWeightsLength { get { int o = __p.__offset(58); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<float> GetRotationWeightsBytes() { return __p.__vector_as_span<float>(58, 4); }
#else
  public ArraySegment<byte>? GetRotationWeightsBytes() { return __p.__vector_as_arraysegment(58); }
#endif
  public float[] GetRotationWeightsArray() { return __p.__vector_as_array<float>(58); }
  public bool IsNoLookByMaterial { get { int o = __p.__offset(60); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public gfl.anm2.fb.Vector4? MaterialUVsNoLook(int j) { int o = __p.__offset(62); return o != 0 ? (gfl.anm2.fb.Vector4?)(new gfl.anm2.fb.Vector4()).__assign(__p.__vector(o) + j * 16, __p.bb) : null; }
  public int MaterialUVsNoLookLength { get { int o = __p.__offset(62); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<gfl.anm2.fb.LookAtGroup> CreateLookAtGroup(FlatBufferBuilder builder,
      StringOffset controlJointNameOffset = default(StringOffset),
      gfl.anm2.fb.Vector3T lookAtAxis = null,
      gfl.anm2.fb.Vector3T lookUpAxis = null,
      gfl.anm2.fb.UpAxisType upAxisType = gfl.anm2.fb.UpAxisType.ZeroXPlusZMinusY,
      float leftClampInDegrees = 0.0f,
      float rightClampInDegrees = 0.0f,
      float upClampInDegrees = 0.0f,
      float downClampInDegrees = 0.0f,
      float horizontalClampBlendRange = 0.0f,
      float verticalClampBlendRange = 0.0f,
      float interpolationTime = 0.0f,
      gfl.anm2.fb.InterpolationType interpolationType = gfl.anm2.fb.InterpolationType.Linear,
      bool isMaterialLookAt = false,
      StringOffset meshNameOffset = default(StringOffset),
      StringOffset materialNameOffset = default(StringOffset),
      gfl.anm2.fb.Vector3T jointOffset = null,
      bool isUseInterpolationRotations = false,
      VectorOffset interpolationPointValuesOffset = default(VectorOffset),
      bool isUseInterpolationTranslations = false,
      VectorOffset interpolationTranslationValuesOffset = default(VectorOffset),
      float rotSpeedPerSecond = 0.0f,
      VectorOffset materialUVUniformNamesOffset = default(VectorOffset),
      float rotSpeedEaseTime = 0.0f,
      float fixedLookAtTime = 0.0f,
      float fixedLookAtAreaInDegrees = 0.0f,
      float fixedLookAtReleaseAreaInDegrees = 0.0f,
      int channelID = 0,
      VectorOffset rotationWeightsOffset = default(VectorOffset),
      bool isNoLookByMaterial = false,
      VectorOffset materialUVsNoLookOffset = default(VectorOffset)) {
    builder.StartTable(30);
    LookAtGroup.AddMaterialUVsNoLook(builder, materialUVsNoLookOffset);
    LookAtGroup.AddRotationWeights(builder, rotationWeightsOffset);
    LookAtGroup.AddChannelID(builder, channelID);
    LookAtGroup.AddFixedLookAtReleaseAreaInDegrees(builder, fixedLookAtReleaseAreaInDegrees);
    LookAtGroup.AddFixedLookAtAreaInDegrees(builder, fixedLookAtAreaInDegrees);
    LookAtGroup.AddFixedLookAtTime(builder, fixedLookAtTime);
    LookAtGroup.AddRotSpeedEaseTime(builder, rotSpeedEaseTime);
    LookAtGroup.AddMaterialUVUniformNames(builder, materialUVUniformNamesOffset);
    LookAtGroup.AddRotSpeedPerSecond(builder, rotSpeedPerSecond);
    LookAtGroup.AddInterpolationTranslationValues(builder, interpolationTranslationValuesOffset);
    LookAtGroup.AddInterpolationPointValues(builder, interpolationPointValuesOffset);
    LookAtGroup.AddJointOffset(builder, gfl.anm2.fb.Vector3.Pack(builder, jointOffset));
    LookAtGroup.AddMaterialName(builder, materialNameOffset);
    LookAtGroup.AddMeshName(builder, meshNameOffset);
    LookAtGroup.AddInterpolationType(builder, interpolationType);
    LookAtGroup.AddInterpolationTime(builder, interpolationTime);
    LookAtGroup.AddVerticalClampBlendRange(builder, verticalClampBlendRange);
    LookAtGroup.AddHorizontalClampBlendRange(builder, horizontalClampBlendRange);
    LookAtGroup.AddDownClampInDegrees(builder, downClampInDegrees);
    LookAtGroup.AddUpClampInDegrees(builder, upClampInDegrees);
    LookAtGroup.AddRightClampInDegrees(builder, rightClampInDegrees);
    LookAtGroup.AddLeftClampInDegrees(builder, leftClampInDegrees);
    LookAtGroup.AddUpAxisType(builder, upAxisType);
    LookAtGroup.AddLookUpAxis(builder, gfl.anm2.fb.Vector3.Pack(builder, lookUpAxis));
    LookAtGroup.AddLookAtAxis(builder, gfl.anm2.fb.Vector3.Pack(builder, lookAtAxis));
    LookAtGroup.AddControlJointName(builder, controlJointNameOffset);
    LookAtGroup.AddIsNoLookByMaterial(builder, isNoLookByMaterial);
    LookAtGroup.AddIsUseInterpolationTranslations(builder, isUseInterpolationTranslations);
    LookAtGroup.AddIsUseInterpolationRotations(builder, isUseInterpolationRotations);
    LookAtGroup.AddIsMaterialLookAt(builder, isMaterialLookAt);
    return LookAtGroup.EndLookAtGroup(builder);
  }

  public static void StartLookAtGroup(FlatBufferBuilder builder) { builder.StartTable(30); }
  public static void AddControlJointName(FlatBufferBuilder builder, StringOffset controlJointNameOffset) { builder.AddOffset(0, controlJointNameOffset.Value, 0); }
  public static void AddLookAtAxis(FlatBufferBuilder builder, Offset<gfl.anm2.fb.Vector3> lookAtAxisOffset) { builder.AddStruct(1, lookAtAxisOffset.Value, 0); }
  public static void AddLookUpAxis(FlatBufferBuilder builder, Offset<gfl.anm2.fb.Vector3> lookUpAxisOffset) { builder.AddStruct(2, lookUpAxisOffset.Value, 0); }
  public static void AddUpAxisType(FlatBufferBuilder builder, gfl.anm2.fb.UpAxisType upAxisType) { builder.AddUint(3, (uint)upAxisType, 0); }
  public static void AddLeftClampInDegrees(FlatBufferBuilder builder, float leftClampInDegrees) { builder.AddFloat(4, leftClampInDegrees, 0.0f); }
  public static void AddRightClampInDegrees(FlatBufferBuilder builder, float rightClampInDegrees) { builder.AddFloat(5, rightClampInDegrees, 0.0f); }
  public static void AddUpClampInDegrees(FlatBufferBuilder builder, float upClampInDegrees) { builder.AddFloat(6, upClampInDegrees, 0.0f); }
  public static void AddDownClampInDegrees(FlatBufferBuilder builder, float downClampInDegrees) { builder.AddFloat(7, downClampInDegrees, 0.0f); }
  public static void AddHorizontalClampBlendRange(FlatBufferBuilder builder, float horizontalClampBlendRange) { builder.AddFloat(8, horizontalClampBlendRange, 0.0f); }
  public static void AddVerticalClampBlendRange(FlatBufferBuilder builder, float verticalClampBlendRange) { builder.AddFloat(9, verticalClampBlendRange, 0.0f); }
  public static void AddInterpolationTime(FlatBufferBuilder builder, float interpolationTime) { builder.AddFloat(10, interpolationTime, 0.0f); }
  public static void AddInterpolationType(FlatBufferBuilder builder, gfl.anm2.fb.InterpolationType interpolationType) { builder.AddUint(11, (uint)interpolationType, 0); }
  public static void AddIsMaterialLookAt(FlatBufferBuilder builder, bool isMaterialLookAt) { builder.AddBool(12, isMaterialLookAt, false); }
  public static void AddMeshName(FlatBufferBuilder builder, StringOffset meshNameOffset) { builder.AddOffset(13, meshNameOffset.Value, 0); }
  public static void AddMaterialName(FlatBufferBuilder builder, StringOffset materialNameOffset) { builder.AddOffset(14, materialNameOffset.Value, 0); }
  public static void AddJointOffset(FlatBufferBuilder builder, Offset<gfl.anm2.fb.Vector3> jointOffsetOffset) { builder.AddStruct(15, jointOffsetOffset.Value, 0); }
  public static void AddIsUseInterpolationRotations(FlatBufferBuilder builder, bool isUseInterpolationRotations) { builder.AddBool(16, isUseInterpolationRotations, false); }
  public static void AddInterpolationPointValues(FlatBufferBuilder builder, VectorOffset interpolationPointValuesOffset) { builder.AddOffset(17, interpolationPointValuesOffset.Value, 0); }
  public static void StartInterpolationPointValuesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(12, numElems, 4); }
  public static void AddIsUseInterpolationTranslations(FlatBufferBuilder builder, bool isUseInterpolationTranslations) { builder.AddBool(18, isUseInterpolationTranslations, false); }
  public static void AddInterpolationTranslationValues(FlatBufferBuilder builder, VectorOffset interpolationTranslationValuesOffset) { builder.AddOffset(19, interpolationTranslationValuesOffset.Value, 0); }
  public static void StartInterpolationTranslationValuesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(12, numElems, 4); }
  public static void AddRotSpeedPerSecond(FlatBufferBuilder builder, float rotSpeedPerSecond) { builder.AddFloat(20, rotSpeedPerSecond, 0.0f); }
  public static void AddMaterialUVUniformNames(FlatBufferBuilder builder, VectorOffset materialUVUniformNamesOffset) { builder.AddOffset(21, materialUVUniformNamesOffset.Value, 0); }
  public static VectorOffset CreateMaterialUVUniformNamesVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateMaterialUVUniformNamesVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartMaterialUVUniformNamesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddRotSpeedEaseTime(FlatBufferBuilder builder, float rotSpeedEaseTime) { builder.AddFloat(22, rotSpeedEaseTime, 0.0f); }
  public static void AddFixedLookAtTime(FlatBufferBuilder builder, float fixedLookAtTime) { builder.AddFloat(23, fixedLookAtTime, 0.0f); }
  public static void AddFixedLookAtAreaInDegrees(FlatBufferBuilder builder, float fixedLookAtAreaInDegrees) { builder.AddFloat(24, fixedLookAtAreaInDegrees, 0.0f); }
  public static void AddFixedLookAtReleaseAreaInDegrees(FlatBufferBuilder builder, float fixedLookAtReleaseAreaInDegrees) { builder.AddFloat(25, fixedLookAtReleaseAreaInDegrees, 0.0f); }
  public static void AddChannelID(FlatBufferBuilder builder, int channelID) { builder.AddInt(26, channelID, 0); }
  public static void AddRotationWeights(FlatBufferBuilder builder, VectorOffset rotationWeightsOffset) { builder.AddOffset(27, rotationWeightsOffset.Value, 0); }
  public static VectorOffset CreateRotationWeightsVector(FlatBufferBuilder builder, float[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddFloat(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateRotationWeightsVectorBlock(FlatBufferBuilder builder, float[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartRotationWeightsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddIsNoLookByMaterial(FlatBufferBuilder builder, bool isNoLookByMaterial) { builder.AddBool(28, isNoLookByMaterial, false); }
  public static void AddMaterialUVsNoLook(FlatBufferBuilder builder, VectorOffset materialUVsNoLookOffset) { builder.AddOffset(29, materialUVsNoLookOffset.Value, 0); }
  public static void StartMaterialUVsNoLookVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(16, numElems, 4); }
  public static Offset<gfl.anm2.fb.LookAtGroup> EndLookAtGroup(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fb.LookAtGroup>(o);
  }
  public LookAtGroupT UnPack() {
    var _o = new LookAtGroupT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(LookAtGroupT _o) {
    _o.ControlJointName = this.ControlJointName;
    _o.LookAtAxis = this.LookAtAxis.HasValue ? this.LookAtAxis.Value.UnPack() : null;
    _o.LookUpAxis = this.LookUpAxis.HasValue ? this.LookUpAxis.Value.UnPack() : null;
    _o.UpAxisType = this.UpAxisType;
    _o.LeftClampInDegrees = this.LeftClampInDegrees;
    _o.RightClampInDegrees = this.RightClampInDegrees;
    _o.UpClampInDegrees = this.UpClampInDegrees;
    _o.DownClampInDegrees = this.DownClampInDegrees;
    _o.HorizontalClampBlendRange = this.HorizontalClampBlendRange;
    _o.VerticalClampBlendRange = this.VerticalClampBlendRange;
    _o.InterpolationTime = this.InterpolationTime;
    _o.InterpolationType = this.InterpolationType;
    _o.IsMaterialLookAt = this.IsMaterialLookAt;
    _o.MeshName = this.MeshName;
    _o.MaterialName = this.MaterialName;
    _o.JointOffset = this.JointOffset.HasValue ? this.JointOffset.Value.UnPack() : null;
    _o.IsUseInterpolationRotations = this.IsUseInterpolationRotations;
    _o.InterpolationPointValues = new List<gfl.anm2.fb.Vector3T>();
    for (var _j = 0; _j < this.InterpolationPointValuesLength; ++_j) {_o.InterpolationPointValues.Add(this.InterpolationPointValues(_j).HasValue ? this.InterpolationPointValues(_j).Value.UnPack() : null);}
    _o.IsUseInterpolationTranslations = this.IsUseInterpolationTranslations;
    _o.InterpolationTranslationValues = new List<gfl.anm2.fb.Vector3T>();
    for (var _j = 0; _j < this.InterpolationTranslationValuesLength; ++_j) {_o.InterpolationTranslationValues.Add(this.InterpolationTranslationValues(_j).HasValue ? this.InterpolationTranslationValues(_j).Value.UnPack() : null);}
    _o.RotSpeedPerSecond = this.RotSpeedPerSecond;
    _o.MaterialUVUniformNames = new List<string>();
    for (var _j = 0; _j < this.MaterialUVUniformNamesLength; ++_j) {_o.MaterialUVUniformNames.Add(this.MaterialUVUniformNames(_j));}
    _o.RotSpeedEaseTime = this.RotSpeedEaseTime;
    _o.FixedLookAtTime = this.FixedLookAtTime;
    _o.FixedLookAtAreaInDegrees = this.FixedLookAtAreaInDegrees;
    _o.FixedLookAtReleaseAreaInDegrees = this.FixedLookAtReleaseAreaInDegrees;
    _o.ChannelID = this.ChannelID;
    _o.RotationWeights = new List<float>();
    for (var _j = 0; _j < this.RotationWeightsLength; ++_j) {_o.RotationWeights.Add(this.RotationWeights(_j));}
    _o.IsNoLookByMaterial = this.IsNoLookByMaterial;
    _o.MaterialUVsNoLook = new List<gfl.anm2.fb.Vector4T>();
    for (var _j = 0; _j < this.MaterialUVsNoLookLength; ++_j) {_o.MaterialUVsNoLook.Add(this.MaterialUVsNoLook(_j).HasValue ? this.MaterialUVsNoLook(_j).Value.UnPack() : null);}
  }
  public static Offset<gfl.anm2.fb.LookAtGroup> Pack(FlatBufferBuilder builder, LookAtGroupT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fb.LookAtGroup>);
    var _controlJointName = _o.ControlJointName == null ? default(StringOffset) : builder.CreateString(_o.ControlJointName);
    var _meshName = _o.MeshName == null ? default(StringOffset) : builder.CreateString(_o.MeshName);
    var _materialName = _o.MaterialName == null ? default(StringOffset) : builder.CreateString(_o.MaterialName);
    var _interpolationPointValues = default(VectorOffset);
    if (_o.InterpolationPointValues != null) {
      StartInterpolationPointValuesVector(builder, _o.InterpolationPointValues.Count);
      for (var _j = _o.InterpolationPointValues.Count - 1; _j >= 0; --_j) { gfl.anm2.fb.Vector3.Pack(builder, _o.InterpolationPointValues[_j]); }
      _interpolationPointValues = builder.EndVector();
    }
    var _interpolationTranslationValues = default(VectorOffset);
    if (_o.InterpolationTranslationValues != null) {
      StartInterpolationTranslationValuesVector(builder, _o.InterpolationTranslationValues.Count);
      for (var _j = _o.InterpolationTranslationValues.Count - 1; _j >= 0; --_j) { gfl.anm2.fb.Vector3.Pack(builder, _o.InterpolationTranslationValues[_j]); }
      _interpolationTranslationValues = builder.EndVector();
    }
    var _materialUVUniformNames = default(VectorOffset);
    if (_o.MaterialUVUniformNames != null) {
      var __materialUVUniformNames = new StringOffset[_o.MaterialUVUniformNames.Count];
      for (var _j = 0; _j < __materialUVUniformNames.Length; ++_j) { __materialUVUniformNames[_j] = builder.CreateString(_o.MaterialUVUniformNames[_j]); }
      _materialUVUniformNames = CreateMaterialUVUniformNamesVector(builder, __materialUVUniformNames);
    }
    var _rotationWeights = default(VectorOffset);
    if (_o.RotationWeights != null) {
      var __rotationWeights = _o.RotationWeights.ToArray();
      _rotationWeights = CreateRotationWeightsVector(builder, __rotationWeights);
    }
    var _materialUVsNoLook = default(VectorOffset);
    if (_o.MaterialUVsNoLook != null) {
      StartMaterialUVsNoLookVector(builder, _o.MaterialUVsNoLook.Count);
      for (var _j = _o.MaterialUVsNoLook.Count - 1; _j >= 0; --_j) { gfl.anm2.fb.Vector4.Pack(builder, _o.MaterialUVsNoLook[_j]); }
      _materialUVsNoLook = builder.EndVector();
    }
    return CreateLookAtGroup(
      builder,
      _controlJointName,
      _o.LookAtAxis,
      _o.LookUpAxis,
      _o.UpAxisType,
      _o.LeftClampInDegrees,
      _o.RightClampInDegrees,
      _o.UpClampInDegrees,
      _o.DownClampInDegrees,
      _o.HorizontalClampBlendRange,
      _o.VerticalClampBlendRange,
      _o.InterpolationTime,
      _o.InterpolationType,
      _o.IsMaterialLookAt,
      _meshName,
      _materialName,
      _o.JointOffset,
      _o.IsUseInterpolationRotations,
      _interpolationPointValues,
      _o.IsUseInterpolationTranslations,
      _interpolationTranslationValues,
      _o.RotSpeedPerSecond,
      _materialUVUniformNames,
      _o.RotSpeedEaseTime,
      _o.FixedLookAtTime,
      _o.FixedLookAtAreaInDegrees,
      _o.FixedLookAtReleaseAreaInDegrees,
      _o.ChannelID,
      _rotationWeights,
      _o.IsNoLookByMaterial,
      _materialUVsNoLook);
  }
};

public class LookAtGroupT
{
  [Newtonsoft.Json.JsonProperty("controlJointName")]
  public string ControlJointName { get; set; }
  [Newtonsoft.Json.JsonProperty("lookAtAxis")]
  public gfl.anm2.fb.Vector3T LookAtAxis { get; set; }
  [Newtonsoft.Json.JsonProperty("lookUpAxis")]
  public gfl.anm2.fb.Vector3T LookUpAxis { get; set; }
  [Newtonsoft.Json.JsonProperty("upAxisType")]
  public gfl.anm2.fb.UpAxisType UpAxisType { get; set; }
  [Newtonsoft.Json.JsonProperty("leftClampInDegrees")]
  public float LeftClampInDegrees { get; set; }
  [Newtonsoft.Json.JsonProperty("rightClampInDegrees")]
  public float RightClampInDegrees { get; set; }
  [Newtonsoft.Json.JsonProperty("upClampInDegrees")]
  public float UpClampInDegrees { get; set; }
  [Newtonsoft.Json.JsonProperty("downClampInDegrees")]
  public float DownClampInDegrees { get; set; }
  [Newtonsoft.Json.JsonProperty("horizontalClampBlendRange")]
  public float HorizontalClampBlendRange { get; set; }
  [Newtonsoft.Json.JsonProperty("verticalClampBlendRange")]
  public float VerticalClampBlendRange { get; set; }
  [Newtonsoft.Json.JsonProperty("interpolationTime")]
  public float InterpolationTime { get; set; }
  [Newtonsoft.Json.JsonProperty("interpolationType")]
  public gfl.anm2.fb.InterpolationType InterpolationType { get; set; }
  [Newtonsoft.Json.JsonProperty("isMaterialLookAt")]
  public bool IsMaterialLookAt { get; set; }
  [Newtonsoft.Json.JsonProperty("meshName")]
  public string MeshName { get; set; }
  [Newtonsoft.Json.JsonProperty("materialName")]
  public string MaterialName { get; set; }
  [Newtonsoft.Json.JsonProperty("jointOffset")]
  public gfl.anm2.fb.Vector3T JointOffset { get; set; }
  [Newtonsoft.Json.JsonProperty("isUseInterpolationRotations")]
  public bool IsUseInterpolationRotations { get; set; }
  [Newtonsoft.Json.JsonProperty("interpolationPointValues")]
  public List<gfl.anm2.fb.Vector3T> InterpolationPointValues { get; set; }
  [Newtonsoft.Json.JsonProperty("isUseInterpolationTranslations")]
  public bool IsUseInterpolationTranslations { get; set; }
  [Newtonsoft.Json.JsonProperty("interpolationTranslationValues")]
  public List<gfl.anm2.fb.Vector3T> InterpolationTranslationValues { get; set; }
  [Newtonsoft.Json.JsonProperty("rotSpeedPerSecond")]
  public float RotSpeedPerSecond { get; set; }
  [Newtonsoft.Json.JsonProperty("materialUVUniformNames")]
  public List<string> MaterialUVUniformNames { get; set; }
  [Newtonsoft.Json.JsonProperty("rotSpeedEaseTime")]
  public float RotSpeedEaseTime { get; set; }
  [Newtonsoft.Json.JsonProperty("fixedLookAtTime")]
  public float FixedLookAtTime { get; set; }
  [Newtonsoft.Json.JsonProperty("fixedLookAtAreaInDegrees")]
  public float FixedLookAtAreaInDegrees { get; set; }
  [Newtonsoft.Json.JsonProperty("fixedLookAtReleaseAreaInDegrees")]
  public float FixedLookAtReleaseAreaInDegrees { get; set; }
  [Newtonsoft.Json.JsonProperty("channelID")]
  public int ChannelID { get; set; }
  [Newtonsoft.Json.JsonProperty("rotationWeights")]
  public List<float> RotationWeights { get; set; }
  [Newtonsoft.Json.JsonProperty("isNoLookByMaterial")]
  public bool IsNoLookByMaterial { get; set; }
  [Newtonsoft.Json.JsonProperty("materialUVsNoLook")]
  public List<gfl.anm2.fb.Vector4T> MaterialUVsNoLook { get; set; }

  public LookAtGroupT() {
    this.ControlJointName = null;
    this.LookAtAxis = new gfl.anm2.fb.Vector3T();
    this.LookUpAxis = new gfl.anm2.fb.Vector3T();
    this.UpAxisType = gfl.anm2.fb.UpAxisType.ZeroXPlusZMinusY;
    this.LeftClampInDegrees = 0.0f;
    this.RightClampInDegrees = 0.0f;
    this.UpClampInDegrees = 0.0f;
    this.DownClampInDegrees = 0.0f;
    this.HorizontalClampBlendRange = 0.0f;
    this.VerticalClampBlendRange = 0.0f;
    this.InterpolationTime = 0.0f;
    this.InterpolationType = gfl.anm2.fb.InterpolationType.Linear;
    this.IsMaterialLookAt = false;
    this.MeshName = null;
    this.MaterialName = null;
    this.JointOffset = new gfl.anm2.fb.Vector3T();
    this.IsUseInterpolationRotations = false;
    this.InterpolationPointValues = null;
    this.IsUseInterpolationTranslations = false;
    this.InterpolationTranslationValues = null;
    this.RotSpeedPerSecond = 0.0f;
    this.MaterialUVUniformNames = null;
    this.RotSpeedEaseTime = 0.0f;
    this.FixedLookAtTime = 0.0f;
    this.FixedLookAtAreaInDegrees = 0.0f;
    this.FixedLookAtReleaseAreaInDegrees = 0.0f;
    this.ChannelID = 0;
    this.RotationWeights = null;
    this.IsNoLookByMaterial = false;
    this.MaterialUVsNoLook = null;
  }
}

public struct LookAtConfig : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static LookAtConfig GetRootAsLookAtConfig(ByteBuffer _bb) { return GetRootAsLookAtConfig(_bb, new LookAtConfig()); }
  public static LookAtConfig GetRootAsLookAtConfig(ByteBuffer _bb, LookAtConfig obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public LookAtConfig __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float InterpolationThreshold { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public gfl.anm2.fb.LookAtGroup? LookAtGroups(int j) { int o = __p.__offset(6); return o != 0 ? (gfl.anm2.fb.LookAtGroup?)(new gfl.anm2.fb.LookAtGroup()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int LookAtGroupsLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
  public gfl.anm2.fb.LookAtType LookAtType { get { int o = __p.__offset(8); return o != 0 ? (gfl.anm2.fb.LookAtType)__p.bb.GetUint(o + __p.bb_pos) : gfl.anm2.fb.LookAtType.InterpolatedPosition; } }
  public bool IsTargetMinDistEnabled { get { int o = __p.__offset(10); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public float TargetMinDist { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public string TargetMinDistJointName { get { int o = __p.__offset(14); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTargetMinDistJointNameBytes() { return __p.__vector_as_span<byte>(14, 1); }
#else
  public ArraySegment<byte>? GetTargetMinDistJointNameBytes() { return __p.__vector_as_arraysegment(14); }
#endif
  public byte[] GetTargetMinDistJointNameArray() { return __p.__vector_as_array<byte>(14); }

  public static Offset<gfl.anm2.fb.LookAtConfig> CreateLookAtConfig(FlatBufferBuilder builder,
      float interpolationThreshold = 0.0f,
      VectorOffset lookAtGroupsOffset = default(VectorOffset),
      gfl.anm2.fb.LookAtType lookAtType = gfl.anm2.fb.LookAtType.InterpolatedPosition,
      bool isTargetMinDistEnabled = false,
      float targetMinDist = 0.0f,
      StringOffset targetMinDistJointNameOffset = default(StringOffset)) {
    builder.StartTable(6);
    LookAtConfig.AddTargetMinDistJointName(builder, targetMinDistJointNameOffset);
    LookAtConfig.AddTargetMinDist(builder, targetMinDist);
    LookAtConfig.AddLookAtType(builder, lookAtType);
    LookAtConfig.AddLookAtGroups(builder, lookAtGroupsOffset);
    LookAtConfig.AddInterpolationThreshold(builder, interpolationThreshold);
    LookAtConfig.AddIsTargetMinDistEnabled(builder, isTargetMinDistEnabled);
    return LookAtConfig.EndLookAtConfig(builder);
  }

  public static void StartLookAtConfig(FlatBufferBuilder builder) { builder.StartTable(6); }
  public static void AddInterpolationThreshold(FlatBufferBuilder builder, float interpolationThreshold) { builder.AddFloat(0, interpolationThreshold, 0.0f); }
  public static void AddLookAtGroups(FlatBufferBuilder builder, VectorOffset lookAtGroupsOffset) { builder.AddOffset(1, lookAtGroupsOffset.Value, 0); }
  public static VectorOffset CreateLookAtGroupsVector(FlatBufferBuilder builder, Offset<gfl.anm2.fb.LookAtGroup>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateLookAtGroupsVectorBlock(FlatBufferBuilder builder, Offset<gfl.anm2.fb.LookAtGroup>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartLookAtGroupsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddLookAtType(FlatBufferBuilder builder, gfl.anm2.fb.LookAtType lookAtType) { builder.AddUint(2, (uint)lookAtType, 0); }
  public static void AddIsTargetMinDistEnabled(FlatBufferBuilder builder, bool isTargetMinDistEnabled) { builder.AddBool(3, isTargetMinDistEnabled, false); }
  public static void AddTargetMinDist(FlatBufferBuilder builder, float targetMinDist) { builder.AddFloat(4, targetMinDist, 0.0f); }
  public static void AddTargetMinDistJointName(FlatBufferBuilder builder, StringOffset targetMinDistJointNameOffset) { builder.AddOffset(5, targetMinDistJointNameOffset.Value, 0); }
  public static Offset<gfl.anm2.fb.LookAtConfig> EndLookAtConfig(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fb.LookAtConfig>(o);
  }
  public static void FinishLookAtConfigBuffer(FlatBufferBuilder builder, Offset<gfl.anm2.fb.LookAtConfig> offset) { builder.Finish(offset.Value); }
  public static void FinishSizePrefixedLookAtConfigBuffer(FlatBufferBuilder builder, Offset<gfl.anm2.fb.LookAtConfig> offset) { builder.FinishSizePrefixed(offset.Value); }
  public LookAtConfigT UnPack() {
    var _o = new LookAtConfigT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(LookAtConfigT _o) {
    _o.InterpolationThreshold = this.InterpolationThreshold;
    _o.LookAtGroups = new List<gfl.anm2.fb.LookAtGroupT>();
    for (var _j = 0; _j < this.LookAtGroupsLength; ++_j) {_o.LookAtGroups.Add(this.LookAtGroups(_j).HasValue ? this.LookAtGroups(_j).Value.UnPack() : null);}
    _o.LookAtType = this.LookAtType;
    _o.IsTargetMinDistEnabled = this.IsTargetMinDistEnabled;
    _o.TargetMinDist = this.TargetMinDist;
    _o.TargetMinDistJointName = this.TargetMinDistJointName;
  }
  public static Offset<gfl.anm2.fb.LookAtConfig> Pack(FlatBufferBuilder builder, LookAtConfigT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fb.LookAtConfig>);
    var _lookAtGroups = default(VectorOffset);
    if (_o.LookAtGroups != null) {
      var __lookAtGroups = new Offset<gfl.anm2.fb.LookAtGroup>[_o.LookAtGroups.Count];
      for (var _j = 0; _j < __lookAtGroups.Length; ++_j) { __lookAtGroups[_j] = gfl.anm2.fb.LookAtGroup.Pack(builder, _o.LookAtGroups[_j]); }
      _lookAtGroups = CreateLookAtGroupsVector(builder, __lookAtGroups);
    }
    var _targetMinDistJointName = _o.TargetMinDistJointName == null ? default(StringOffset) : builder.CreateString(_o.TargetMinDistJointName);
    return CreateLookAtConfig(
      builder,
      _o.InterpolationThreshold,
      _lookAtGroups,
      _o.LookAtType,
      _o.IsTargetMinDistEnabled,
      _o.TargetMinDist,
      _targetMinDistJointName);
  }
};

public class LookAtConfigT
{
  [Newtonsoft.Json.JsonProperty("interpolationThreshold")]
  public float InterpolationThreshold { get; set; }
  [Newtonsoft.Json.JsonProperty("lookAtGroups")]
  public List<gfl.anm2.fb.LookAtGroupT> LookAtGroups { get; set; }
  [Newtonsoft.Json.JsonProperty("lookAtType")]
  public gfl.anm2.fb.LookAtType LookAtType { get; set; }
  [Newtonsoft.Json.JsonProperty("isTargetMinDistEnabled")]
  public bool IsTargetMinDistEnabled { get; set; }
  [Newtonsoft.Json.JsonProperty("targetMinDist")]
  public float TargetMinDist { get; set; }
  [Newtonsoft.Json.JsonProperty("targetMinDistJointName")]
  public string TargetMinDistJointName { get; set; }

  public LookAtConfigT() {
    this.InterpolationThreshold = 0.0f;
    this.LookAtGroups = null;
    this.LookAtType = gfl.anm2.fb.LookAtType.InterpolatedPosition;
    this.IsTargetMinDistEnabled = false;
    this.TargetMinDist = 0.0f;
    this.TargetMinDistJointName = null;
  }

  public static LookAtConfigT DeserializeFromJson(string jsonText) {
    return Newtonsoft.Json.JsonConvert.DeserializeObject<LookAtConfigT>(jsonText);
  }
  public string SerializeToJson() {
    return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
  }
  public static LookAtConfigT DeserializeFromBinary(byte[] fbBuffer) {
    return LookAtConfig.GetRootAsLookAtConfig(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    LookAtConfig.FinishLookAtConfigBuffer(fbb, LookAtConfig.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


}
