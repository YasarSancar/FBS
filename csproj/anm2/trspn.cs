// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace gfl.anm2.fb
{

using global::System;
using global::System.Collections.Generic;
using global::FlatBuffers;

public struct SpineAnimationData : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static SpineAnimationData GetRootAsSpineAnimationData(ByteBuffer _bb) { return GetRootAsSpineAnimationData(_bb, new SpineAnimationData()); }
  public static SpineAnimationData GetRootAsSpineAnimationData(ByteBuffer _bb, SpineAnimationData obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SpineAnimationData __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public bool IsEnabled { get { int o = __p.__offset(4); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool IsLastJointLeading { get { int o = __p.__offset(6); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool IsInitWithBasePose { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool IsIgnoreMotion { get { int o = __p.__offset(10); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool IsIgnorePosition { get { int o = __p.__offset(12); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool IsLimitAngleToOriginal { get { int o = __p.__offset(14); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool IsLateUpdate { get { int o = __p.__offset(16); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public string StartJointName { get { int o = __p.__offset(18); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetStartJointNameBytes() { return __p.__vector_as_span<byte>(18, 1); }
#else
  public ArraySegment<byte>? GetStartJointNameBytes() { return __p.__vector_as_arraysegment(18); }
#endif
  public byte[] GetStartJointNameArray() { return __p.__vector_as_array<byte>(18); }
  public string EndJointName { get { int o = __p.__offset(20); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetEndJointNameBytes() { return __p.__vector_as_span<byte>(20, 1); }
#else
  public ArraySegment<byte>? GetEndJointNameBytes() { return __p.__vector_as_arraysegment(20); }
#endif
  public byte[] GetEndJointNameArray() { return __p.__vector_as_array<byte>(20); }
  public float AngleLimit { get { int o = __p.__offset(22); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float BlendToOriginal { get { int o = __p.__offset(24); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float PosSmooth { get { int o = __p.__offset(26); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float RotSmooth { get { int o = __p.__offset(28); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float RotCorrectStrength { get { int o = __p.__offset(30); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float StraightenStrength { get { int o = __p.__offset(32); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public bool IsOverwriteBaseRotation { get { int o = __p.__offset(34); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public gfl.anm2.fb.Vector3? OverwriteRotation { get { int o = __p.__offset(36); return o != 0 ? (gfl.anm2.fb.Vector3?)(new gfl.anm2.fb.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public bool IsStraightenToPreviousJoint { get { int o = __p.__offset(38); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public float StraightenThreshold { get { int o = __p.__offset(40); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<gfl.anm2.fb.SpineAnimationData> CreateSpineAnimationData(FlatBufferBuilder builder,
      bool isEnabled = false,
      bool isLastJointLeading = false,
      bool isInitWithBasePose = false,
      bool isIgnoreMotion = false,
      bool isIgnorePosition = false,
      bool isLimitAngleToOriginal = false,
      bool isLateUpdate = false,
      StringOffset startJointNameOffset = default(StringOffset),
      StringOffset endJointNameOffset = default(StringOffset),
      float angleLimit = 0.0f,
      float blendToOriginal = 0.0f,
      float posSmooth = 0.0f,
      float rotSmooth = 0.0f,
      float rotCorrectStrength = 0.0f,
      float straightenStrength = 0.0f,
      bool isOverwriteBaseRotation = false,
      gfl.anm2.fb.Vector3T overwriteRotation = null,
      bool isStraightenToPreviousJoint = false,
      float straightenThreshold = 0.0f) {
    builder.StartTable(19);
    SpineAnimationData.AddStraightenThreshold(builder, straightenThreshold);
    SpineAnimationData.AddOverwriteRotation(builder, gfl.anm2.fb.Vector3.Pack(builder, overwriteRotation));
    SpineAnimationData.AddStraightenStrength(builder, straightenStrength);
    SpineAnimationData.AddRotCorrectStrength(builder, rotCorrectStrength);
    SpineAnimationData.AddRotSmooth(builder, rotSmooth);
    SpineAnimationData.AddPosSmooth(builder, posSmooth);
    SpineAnimationData.AddBlendToOriginal(builder, blendToOriginal);
    SpineAnimationData.AddAngleLimit(builder, angleLimit);
    SpineAnimationData.AddEndJointName(builder, endJointNameOffset);
    SpineAnimationData.AddStartJointName(builder, startJointNameOffset);
    SpineAnimationData.AddIsStraightenToPreviousJoint(builder, isStraightenToPreviousJoint);
    SpineAnimationData.AddIsOverwriteBaseRotation(builder, isOverwriteBaseRotation);
    SpineAnimationData.AddIsLateUpdate(builder, isLateUpdate);
    SpineAnimationData.AddIsLimitAngleToOriginal(builder, isLimitAngleToOriginal);
    SpineAnimationData.AddIsIgnorePosition(builder, isIgnorePosition);
    SpineAnimationData.AddIsIgnoreMotion(builder, isIgnoreMotion);
    SpineAnimationData.AddIsInitWithBasePose(builder, isInitWithBasePose);
    SpineAnimationData.AddIsLastJointLeading(builder, isLastJointLeading);
    SpineAnimationData.AddIsEnabled(builder, isEnabled);
    return SpineAnimationData.EndSpineAnimationData(builder);
  }

  public static void StartSpineAnimationData(FlatBufferBuilder builder) { builder.StartTable(19); }
  public static void AddIsEnabled(FlatBufferBuilder builder, bool isEnabled) { builder.AddBool(0, isEnabled, false); }
  public static void AddIsLastJointLeading(FlatBufferBuilder builder, bool isLastJointLeading) { builder.AddBool(1, isLastJointLeading, false); }
  public static void AddIsInitWithBasePose(FlatBufferBuilder builder, bool isInitWithBasePose) { builder.AddBool(2, isInitWithBasePose, false); }
  public static void AddIsIgnoreMotion(FlatBufferBuilder builder, bool isIgnoreMotion) { builder.AddBool(3, isIgnoreMotion, false); }
  public static void AddIsIgnorePosition(FlatBufferBuilder builder, bool isIgnorePosition) { builder.AddBool(4, isIgnorePosition, false); }
  public static void AddIsLimitAngleToOriginal(FlatBufferBuilder builder, bool isLimitAngleToOriginal) { builder.AddBool(5, isLimitAngleToOriginal, false); }
  public static void AddIsLateUpdate(FlatBufferBuilder builder, bool isLateUpdate) { builder.AddBool(6, isLateUpdate, false); }
  public static void AddStartJointName(FlatBufferBuilder builder, StringOffset startJointNameOffset) { builder.AddOffset(7, startJointNameOffset.Value, 0); }
  public static void AddEndJointName(FlatBufferBuilder builder, StringOffset endJointNameOffset) { builder.AddOffset(8, endJointNameOffset.Value, 0); }
  public static void AddAngleLimit(FlatBufferBuilder builder, float angleLimit) { builder.AddFloat(9, angleLimit, 0.0f); }
  public static void AddBlendToOriginal(FlatBufferBuilder builder, float blendToOriginal) { builder.AddFloat(10, blendToOriginal, 0.0f); }
  public static void AddPosSmooth(FlatBufferBuilder builder, float posSmooth) { builder.AddFloat(11, posSmooth, 0.0f); }
  public static void AddRotSmooth(FlatBufferBuilder builder, float rotSmooth) { builder.AddFloat(12, rotSmooth, 0.0f); }
  public static void AddRotCorrectStrength(FlatBufferBuilder builder, float rotCorrectStrength) { builder.AddFloat(13, rotCorrectStrength, 0.0f); }
  public static void AddStraightenStrength(FlatBufferBuilder builder, float straightenStrength) { builder.AddFloat(14, straightenStrength, 0.0f); }
  public static void AddIsOverwriteBaseRotation(FlatBufferBuilder builder, bool isOverwriteBaseRotation) { builder.AddBool(15, isOverwriteBaseRotation, false); }
  public static void AddOverwriteRotation(FlatBufferBuilder builder, Offset<gfl.anm2.fb.Vector3> overwriteRotationOffset) { builder.AddStruct(16, overwriteRotationOffset.Value, 0); }
  public static void AddIsStraightenToPreviousJoint(FlatBufferBuilder builder, bool isStraightenToPreviousJoint) { builder.AddBool(17, isStraightenToPreviousJoint, false); }
  public static void AddStraightenThreshold(FlatBufferBuilder builder, float straightenThreshold) { builder.AddFloat(18, straightenThreshold, 0.0f); }
  public static Offset<gfl.anm2.fb.SpineAnimationData> EndSpineAnimationData(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fb.SpineAnimationData>(o);
  }
  public SpineAnimationDataT UnPack() {
    var _o = new SpineAnimationDataT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(SpineAnimationDataT _o) {
    _o.IsEnabled = this.IsEnabled;
    _o.IsLastJointLeading = this.IsLastJointLeading;
    _o.IsInitWithBasePose = this.IsInitWithBasePose;
    _o.IsIgnoreMotion = this.IsIgnoreMotion;
    _o.IsIgnorePosition = this.IsIgnorePosition;
    _o.IsLimitAngleToOriginal = this.IsLimitAngleToOriginal;
    _o.IsLateUpdate = this.IsLateUpdate;
    _o.StartJointName = this.StartJointName;
    _o.EndJointName = this.EndJointName;
    _o.AngleLimit = this.AngleLimit;
    _o.BlendToOriginal = this.BlendToOriginal;
    _o.PosSmooth = this.PosSmooth;
    _o.RotSmooth = this.RotSmooth;
    _o.RotCorrectStrength = this.RotCorrectStrength;
    _o.StraightenStrength = this.StraightenStrength;
    _o.IsOverwriteBaseRotation = this.IsOverwriteBaseRotation;
    _o.OverwriteRotation = this.OverwriteRotation.HasValue ? this.OverwriteRotation.Value.UnPack() : null;
    _o.IsStraightenToPreviousJoint = this.IsStraightenToPreviousJoint;
    _o.StraightenThreshold = this.StraightenThreshold;
  }
  public static Offset<gfl.anm2.fb.SpineAnimationData> Pack(FlatBufferBuilder builder, SpineAnimationDataT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fb.SpineAnimationData>);
    var _startJointName = _o.StartJointName == null ? default(StringOffset) : builder.CreateString(_o.StartJointName);
    var _endJointName = _o.EndJointName == null ? default(StringOffset) : builder.CreateString(_o.EndJointName);
    return CreateSpineAnimationData(
      builder,
      _o.IsEnabled,
      _o.IsLastJointLeading,
      _o.IsInitWithBasePose,
      _o.IsIgnoreMotion,
      _o.IsIgnorePosition,
      _o.IsLimitAngleToOriginal,
      _o.IsLateUpdate,
      _startJointName,
      _endJointName,
      _o.AngleLimit,
      _o.BlendToOriginal,
      _o.PosSmooth,
      _o.RotSmooth,
      _o.RotCorrectStrength,
      _o.StraightenStrength,
      _o.IsOverwriteBaseRotation,
      _o.OverwriteRotation,
      _o.IsStraightenToPreviousJoint,
      _o.StraightenThreshold);
  }
};

public class SpineAnimationDataT
{
  [Newtonsoft.Json.JsonProperty("isEnabled")]
  public bool IsEnabled { get; set; }
  [Newtonsoft.Json.JsonProperty("isLastJointLeading")]
  public bool IsLastJointLeading { get; set; }
  [Newtonsoft.Json.JsonProperty("isInitWithBasePose")]
  public bool IsInitWithBasePose { get; set; }
  [Newtonsoft.Json.JsonProperty("isIgnoreMotion")]
  public bool IsIgnoreMotion { get; set; }
  [Newtonsoft.Json.JsonProperty("isIgnorePosition")]
  public bool IsIgnorePosition { get; set; }
  [Newtonsoft.Json.JsonProperty("isLimitAngleToOriginal")]
  public bool IsLimitAngleToOriginal { get; set; }
  [Newtonsoft.Json.JsonProperty("isLateUpdate")]
  public bool IsLateUpdate { get; set; }
  [Newtonsoft.Json.JsonProperty("startJointName")]
  public string StartJointName { get; set; }
  [Newtonsoft.Json.JsonProperty("endJointName")]
  public string EndJointName { get; set; }
  [Newtonsoft.Json.JsonProperty("angleLimit")]
  public float AngleLimit { get; set; }
  [Newtonsoft.Json.JsonProperty("blendToOriginal")]
  public float BlendToOriginal { get; set; }
  [Newtonsoft.Json.JsonProperty("posSmooth")]
  public float PosSmooth { get; set; }
  [Newtonsoft.Json.JsonProperty("rotSmooth")]
  public float RotSmooth { get; set; }
  [Newtonsoft.Json.JsonProperty("rotCorrectStrength")]
  public float RotCorrectStrength { get; set; }
  [Newtonsoft.Json.JsonProperty("straightenStrength")]
  public float StraightenStrength { get; set; }
  [Newtonsoft.Json.JsonProperty("isOverwriteBaseRotation")]
  public bool IsOverwriteBaseRotation { get; set; }
  [Newtonsoft.Json.JsonProperty("overwriteRotation")]
  public gfl.anm2.fb.Vector3T OverwriteRotation { get; set; }
  [Newtonsoft.Json.JsonProperty("isStraightenToPreviousJoint")]
  public bool IsStraightenToPreviousJoint { get; set; }
  [Newtonsoft.Json.JsonProperty("straightenThreshold")]
  public float StraightenThreshold { get; set; }

  public SpineAnimationDataT() {
    this.IsEnabled = false;
    this.IsLastJointLeading = false;
    this.IsInitWithBasePose = false;
    this.IsIgnoreMotion = false;
    this.IsIgnorePosition = false;
    this.IsLimitAngleToOriginal = false;
    this.IsLateUpdate = false;
    this.StartJointName = null;
    this.EndJointName = null;
    this.AngleLimit = 0.0f;
    this.BlendToOriginal = 0.0f;
    this.PosSmooth = 0.0f;
    this.RotSmooth = 0.0f;
    this.RotCorrectStrength = 0.0f;
    this.StraightenStrength = 0.0f;
    this.IsOverwriteBaseRotation = false;
    this.OverwriteRotation = new gfl.anm2.fb.Vector3T();
    this.IsStraightenToPreviousJoint = false;
    this.StraightenThreshold = 0.0f;
  }
}

public struct SpineAnimationConfig : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static SpineAnimationConfig GetRootAsSpineAnimationConfig(ByteBuffer _bb) { return GetRootAsSpineAnimationConfig(_bb, new SpineAnimationConfig()); }
  public static SpineAnimationConfig GetRootAsSpineAnimationConfig(ByteBuffer _bb, SpineAnimationConfig obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SpineAnimationConfig __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public gfl.anm2.fb.SpineAnimationData? SpineAnimationData(int j) { int o = __p.__offset(4); return o != 0 ? (gfl.anm2.fb.SpineAnimationData?)(new gfl.anm2.fb.SpineAnimationData()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int SpineAnimationDataLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<gfl.anm2.fb.SpineAnimationConfig> CreateSpineAnimationConfig(FlatBufferBuilder builder,
      VectorOffset spineAnimationDataOffset = default(VectorOffset)) {
    builder.StartTable(1);
    SpineAnimationConfig.AddSpineAnimationData(builder, spineAnimationDataOffset);
    return SpineAnimationConfig.EndSpineAnimationConfig(builder);
  }

  public static void StartSpineAnimationConfig(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddSpineAnimationData(FlatBufferBuilder builder, VectorOffset spineAnimationDataOffset) { builder.AddOffset(0, spineAnimationDataOffset.Value, 0); }
  public static VectorOffset CreateSpineAnimationDataVector(FlatBufferBuilder builder, Offset<gfl.anm2.fb.SpineAnimationData>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateSpineAnimationDataVectorBlock(FlatBufferBuilder builder, Offset<gfl.anm2.fb.SpineAnimationData>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartSpineAnimationDataVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<gfl.anm2.fb.SpineAnimationConfig> EndSpineAnimationConfig(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fb.SpineAnimationConfig>(o);
  }
  public static void FinishSpineAnimationConfigBuffer(FlatBufferBuilder builder, Offset<gfl.anm2.fb.SpineAnimationConfig> offset) { builder.Finish(offset.Value); }
  public static void FinishSizePrefixedSpineAnimationConfigBuffer(FlatBufferBuilder builder, Offset<gfl.anm2.fb.SpineAnimationConfig> offset) { builder.FinishSizePrefixed(offset.Value); }
  public SpineAnimationConfigT UnPack() {
    var _o = new SpineAnimationConfigT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(SpineAnimationConfigT _o) {
    _o.SpineAnimationData = new List<gfl.anm2.fb.SpineAnimationDataT>();
    for (var _j = 0; _j < this.SpineAnimationDataLength; ++_j) {_o.SpineAnimationData.Add(this.SpineAnimationData(_j).HasValue ? this.SpineAnimationData(_j).Value.UnPack() : null);}
  }
  public static Offset<gfl.anm2.fb.SpineAnimationConfig> Pack(FlatBufferBuilder builder, SpineAnimationConfigT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fb.SpineAnimationConfig>);
    var _spineAnimationData = default(VectorOffset);
    if (_o.SpineAnimationData != null) {
      var __spineAnimationData = new Offset<gfl.anm2.fb.SpineAnimationData>[_o.SpineAnimationData.Count];
      for (var _j = 0; _j < __spineAnimationData.Length; ++_j) { __spineAnimationData[_j] = gfl.anm2.fb.SpineAnimationData.Pack(builder, _o.SpineAnimationData[_j]); }
      _spineAnimationData = CreateSpineAnimationDataVector(builder, __spineAnimationData);
    }
    return CreateSpineAnimationConfig(
      builder,
      _spineAnimationData);
  }
};

public class SpineAnimationConfigT
{
  [Newtonsoft.Json.JsonProperty("spineAnimationData")]
  public List<gfl.anm2.fb.SpineAnimationDataT> SpineAnimationData { get; set; }

  public SpineAnimationConfigT() {
    this.SpineAnimationData = null;
  }

  public static SpineAnimationConfigT DeserializeFromJson(string jsonText) {
    return Newtonsoft.Json.JsonConvert.DeserializeObject<SpineAnimationConfigT>(jsonText);
  }
  public string SerializeToJson() {
    return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
  }
  public static SpineAnimationConfigT DeserializeFromBinary(byte[] fbBuffer) {
    return SpineAnimationConfig.GetRootAsSpineAnimationConfig(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    SpineAnimationConfig.FinishSpineAnimationConfigBuffer(fbb, SpineAnimationConfig.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


}
