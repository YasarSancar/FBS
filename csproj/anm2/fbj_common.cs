// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace gfl.anm2.fbj
{

using global::System;
using global::System.Collections.Generic;
using global::FlatBuffers;

[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
public enum PlayMode : uint
{
  Once = 0,
  Loop = 1,
};

[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
public enum KeyType : byte
{
  NONE = 0,
  BoolKey = 1,
  DoubleKey = 2,
  HermiteKey = 3,
};

public class KeyTypeUnion {
  public KeyType Type { get; set; }
  public object Value { get; set; }

  public KeyTypeUnion() {
    this.Type = KeyType.NONE;
    this.Value = null;
  }

  public T As<T>() where T : class { return this.Value as T; }
  public gfl.anm2.fbj.BoolKeyT AsBoolKey() { return this.As<gfl.anm2.fbj.BoolKeyT>(); }
  public gfl.anm2.fbj.DoubleKeyT AsDoubleKey() { return this.As<gfl.anm2.fbj.DoubleKeyT>(); }
  public gfl.anm2.fbj.HermiteKeyT AsHermiteKey() { return this.As<gfl.anm2.fbj.HermiteKeyT>(); }

  public static int Pack(FlatBuffers.FlatBufferBuilder builder, KeyTypeUnion _o) {
    switch (_o.Type) {
      default: return 0;
      case KeyType.BoolKey: return gfl.anm2.fbj.BoolKey.Pack(builder, _o.AsBoolKey()).Value;
      case KeyType.DoubleKey: return gfl.anm2.fbj.DoubleKey.Pack(builder, _o.AsDoubleKey()).Value;
      case KeyType.HermiteKey: return gfl.anm2.fbj.HermiteKey.Pack(builder, _o.AsHermiteKey()).Value;
    }
  }
}

public class KeyTypeUnion_JsonConverter : Newtonsoft.Json.JsonConverter {
  public override bool CanConvert(System.Type objectType) {
    return objectType == typeof(KeyTypeUnion) || objectType == typeof(System.Collections.Generic.List<KeyTypeUnion>);
  }
  public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object value, Newtonsoft.Json.JsonSerializer serializer) {
    var _olist = value as System.Collections.Generic.List<KeyTypeUnion>;
    if (_olist != null) {
      writer.WriteStartArray();
      foreach (var _o in _olist) { this.WriteJson(writer, _o, serializer); }
      writer.WriteEndArray();
    } else {
      this.WriteJson(writer, value as KeyTypeUnion, serializer);
    }
  }
  public void WriteJson(Newtonsoft.Json.JsonWriter writer, KeyTypeUnion _o, Newtonsoft.Json.JsonSerializer serializer) {
    if (_o == null) return;
    serializer.Serialize(writer, _o.Value);
  }
  public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type objectType, object existingValue, Newtonsoft.Json.JsonSerializer serializer) {
    var _olist = existingValue as System.Collections.Generic.List<KeyTypeUnion>;
    if (_olist != null) {
      for (var _j = 0; _j < _olist.Count; ++_j) {
        reader.Read();
        _olist[_j] = this.ReadJson(reader, _olist[_j], serializer);
      }
      reader.Read();
      return _olist;
    } else {
      return this.ReadJson(reader, existingValue as KeyTypeUnion, serializer);
    }
  }
  public KeyTypeUnion ReadJson(Newtonsoft.Json.JsonReader reader, KeyTypeUnion _o, Newtonsoft.Json.JsonSerializer serializer) {
    if (_o == null) return null;
    switch (_o.Type) {
      default: break;
      case KeyType.BoolKey: _o.Value = serializer.Deserialize<gfl.anm2.fbj.BoolKeyT>(reader); break;
      case KeyType.DoubleKey: _o.Value = serializer.Deserialize<gfl.anm2.fbj.DoubleKeyT>(reader); break;
      case KeyType.HermiteKey: _o.Value = serializer.Deserialize<gfl.anm2.fbj.HermiteKeyT>(reader); break;
    }
    return _o;
  }
}

public struct ExporterInfo : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static ExporterInfo GetRootAsExporterInfo(ByteBuffer _bb) { return GetRootAsExporterInfo(_bb, new ExporterInfo()); }
  public static ExporterInfo GetRootAsExporterInfo(ByteBuffer _bb, ExporterInfo obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ExporterInfo __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Name { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(4); }
  public string Version { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetVersionBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetVersionBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetVersionArray() { return __p.__vector_as_array<byte>(6); }

  public static Offset<gfl.anm2.fbj.ExporterInfo> CreateExporterInfo(FlatBufferBuilder builder,
      StringOffset nameOffset = default(StringOffset),
      StringOffset versionOffset = default(StringOffset)) {
    builder.StartTable(2);
    ExporterInfo.AddVersion(builder, versionOffset);
    ExporterInfo.AddName(builder, nameOffset);
    return ExporterInfo.EndExporterInfo(builder);
  }

  public static void StartExporterInfo(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(0, nameOffset.Value, 0); }
  public static void AddVersion(FlatBufferBuilder builder, StringOffset versionOffset) { builder.AddOffset(1, versionOffset.Value, 0); }
  public static Offset<gfl.anm2.fbj.ExporterInfo> EndExporterInfo(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fbj.ExporterInfo>(o);
  }
  public ExporterInfoT UnPack() {
    var _o = new ExporterInfoT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(ExporterInfoT _o) {
    _o.Name = this.Name;
    _o.Version = this.Version;
  }
  public static Offset<gfl.anm2.fbj.ExporterInfo> Pack(FlatBufferBuilder builder, ExporterInfoT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fbj.ExporterInfo>);
    var _name = _o.Name == null ? default(StringOffset) : builder.CreateString(_o.Name);
    var _version = _o.Version == null ? default(StringOffset) : builder.CreateString(_o.Version);
    return CreateExporterInfo(
      builder,
      _name,
      _version);
  }
};

public class ExporterInfoT
{
  [Newtonsoft.Json.JsonProperty("name")]
  public string Name { get; set; }
  [Newtonsoft.Json.JsonProperty("version")]
  public string Version { get; set; }

  public ExporterInfoT() {
    this.Name = null;
    this.Version = null;
  }
}

public struct DccSource : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static DccSource GetRootAsDccSource(ByteBuffer _bb) { return GetRootAsDccSource(_bb, new DccSource()); }
  public static DccSource GetRootAsDccSource(ByteBuffer _bb, DccSource obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public DccSource __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Path { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPathBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetPathBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetPathArray() { return __p.__vector_as_array<byte>(4); }
  public string TargetNode { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTargetNodeBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetTargetNodeBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetTargetNodeArray() { return __p.__vector_as_array<byte>(6); }

  public static Offset<gfl.anm2.fbj.DccSource> CreateDccSource(FlatBufferBuilder builder,
      StringOffset pathOffset = default(StringOffset),
      StringOffset targetNodeOffset = default(StringOffset)) {
    builder.StartTable(2);
    DccSource.AddTargetNode(builder, targetNodeOffset);
    DccSource.AddPath(builder, pathOffset);
    return DccSource.EndDccSource(builder);
  }

  public static void StartDccSource(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddPath(FlatBufferBuilder builder, StringOffset pathOffset) { builder.AddOffset(0, pathOffset.Value, 0); }
  public static void AddTargetNode(FlatBufferBuilder builder, StringOffset targetNodeOffset) { builder.AddOffset(1, targetNodeOffset.Value, 0); }
  public static Offset<gfl.anm2.fbj.DccSource> EndDccSource(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fbj.DccSource>(o);
  }
  public DccSourceT UnPack() {
    var _o = new DccSourceT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(DccSourceT _o) {
    _o.Path = this.Path;
    _o.TargetNode = this.TargetNode;
  }
  public static Offset<gfl.anm2.fbj.DccSource> Pack(FlatBufferBuilder builder, DccSourceT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fbj.DccSource>);
    var _path = _o.Path == null ? default(StringOffset) : builder.CreateString(_o.Path);
    var _targetNode = _o.TargetNode == null ? default(StringOffset) : builder.CreateString(_o.TargetNode);
    return CreateDccSource(
      builder,
      _path,
      _targetNode);
  }
};

public class DccSourceT
{
  [Newtonsoft.Json.JsonProperty("path")]
  public string Path { get; set; }
  [Newtonsoft.Json.JsonProperty("targetNode")]
  public string TargetNode { get; set; }

  public DccSourceT() {
    this.Path = null;
    this.TargetNode = null;
  }
}

public struct FrameSetting : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static FrameSetting GetRootAsFrameSetting(ByteBuffer _bb) { return GetRootAsFrameSetting(_bb, new FrameSetting()); }
  public static FrameSetting GetRootAsFrameSetting(ByteBuffer _bb, FrameSetting obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public FrameSetting __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int StartFrame { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int EndFrame { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int FrameCount { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public gfl.anm2.fbj.PlayMode PlayMode { get { int o = __p.__offset(10); return o != 0 ? (gfl.anm2.fbj.PlayMode)__p.bb.GetUint(o + __p.bb_pos) : gfl.anm2.fbj.PlayMode.Once; } }
  public int Fps { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public bool ReverseEnabled { get { int o = __p.__offset(14); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public string LayerName { get { int o = __p.__offset(16); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetLayerNameBytes() { return __p.__vector_as_span<byte>(16, 1); }
#else
  public ArraySegment<byte>? GetLayerNameBytes() { return __p.__vector_as_arraysegment(16); }
#endif
  public byte[] GetLayerNameArray() { return __p.__vector_as_array<byte>(16); }

  public static Offset<gfl.anm2.fbj.FrameSetting> CreateFrameSetting(FlatBufferBuilder builder,
      int startFrame = 0,
      int endFrame = 0,
      int frameCount = 0,
      gfl.anm2.fbj.PlayMode playMode = gfl.anm2.fbj.PlayMode.Once,
      int fps = 0,
      bool reverseEnabled = false,
      StringOffset layerNameOffset = default(StringOffset)) {
    builder.StartTable(7);
    FrameSetting.AddLayerName(builder, layerNameOffset);
    FrameSetting.AddFps(builder, fps);
    FrameSetting.AddPlayMode(builder, playMode);
    FrameSetting.AddFrameCount(builder, frameCount);
    FrameSetting.AddEndFrame(builder, endFrame);
    FrameSetting.AddStartFrame(builder, startFrame);
    FrameSetting.AddReverseEnabled(builder, reverseEnabled);
    return FrameSetting.EndFrameSetting(builder);
  }

  public static void StartFrameSetting(FlatBufferBuilder builder) { builder.StartTable(7); }
  public static void AddStartFrame(FlatBufferBuilder builder, int startFrame) { builder.AddInt(0, startFrame, 0); }
  public static void AddEndFrame(FlatBufferBuilder builder, int endFrame) { builder.AddInt(1, endFrame, 0); }
  public static void AddFrameCount(FlatBufferBuilder builder, int frameCount) { builder.AddInt(2, frameCount, 0); }
  public static void AddPlayMode(FlatBufferBuilder builder, gfl.anm2.fbj.PlayMode playMode) { builder.AddUint(3, (uint)playMode, 0); }
  public static void AddFps(FlatBufferBuilder builder, int fps) { builder.AddInt(4, fps, 0); }
  public static void AddReverseEnabled(FlatBufferBuilder builder, bool reverseEnabled) { builder.AddBool(5, reverseEnabled, false); }
  public static void AddLayerName(FlatBufferBuilder builder, StringOffset layerNameOffset) { builder.AddOffset(6, layerNameOffset.Value, 0); }
  public static Offset<gfl.anm2.fbj.FrameSetting> EndFrameSetting(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fbj.FrameSetting>(o);
  }
  public FrameSettingT UnPack() {
    var _o = new FrameSettingT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(FrameSettingT _o) {
    _o.StartFrame = this.StartFrame;
    _o.EndFrame = this.EndFrame;
    _o.FrameCount = this.FrameCount;
    _o.PlayMode = this.PlayMode;
    _o.Fps = this.Fps;
    _o.ReverseEnabled = this.ReverseEnabled;
    _o.LayerName = this.LayerName;
  }
  public static Offset<gfl.anm2.fbj.FrameSetting> Pack(FlatBufferBuilder builder, FrameSettingT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fbj.FrameSetting>);
    var _layerName = _o.LayerName == null ? default(StringOffset) : builder.CreateString(_o.LayerName);
    return CreateFrameSetting(
      builder,
      _o.StartFrame,
      _o.EndFrame,
      _o.FrameCount,
      _o.PlayMode,
      _o.Fps,
      _o.ReverseEnabled,
      _layerName);
  }
};

public class FrameSettingT
{
  [Newtonsoft.Json.JsonProperty("startFrame")]
  public int StartFrame { get; set; }
  [Newtonsoft.Json.JsonProperty("endFrame")]
  public int EndFrame { get; set; }
  [Newtonsoft.Json.JsonProperty("frameCount")]
  public int FrameCount { get; set; }
  [Newtonsoft.Json.JsonProperty("playMode")]
  public gfl.anm2.fbj.PlayMode PlayMode { get; set; }
  [Newtonsoft.Json.JsonProperty("fps")]
  public int Fps { get; set; }
  [Newtonsoft.Json.JsonProperty("reverseEnabled")]
  public bool ReverseEnabled { get; set; }
  [Newtonsoft.Json.JsonProperty("layerName")]
  public string LayerName { get; set; }

  public FrameSettingT() {
    this.StartFrame = 0;
    this.EndFrame = 0;
    this.FrameCount = 0;
    this.PlayMode = gfl.anm2.fbj.PlayMode.Once;
    this.Fps = 0;
    this.ReverseEnabled = false;
    this.LayerName = null;
  }
}

public struct Vector3 : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static Vector3 GetRootAsVector3(ByteBuffer _bb) { return GetRootAsVector3(_bb, new Vector3()); }
  public static Vector3 GetRootAsVector3(ByteBuffer _bb, Vector3 obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Vector3 __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float X { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float Y { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float Z { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<gfl.anm2.fbj.Vector3> CreateVector3(FlatBufferBuilder builder,
      float x = 0.0f,
      float y = 0.0f,
      float z = 0.0f) {
    builder.StartTable(3);
    Vector3.AddZ(builder, z);
    Vector3.AddY(builder, y);
    Vector3.AddX(builder, x);
    return Vector3.EndVector3(builder);
  }

  public static void StartVector3(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddX(FlatBufferBuilder builder, float x) { builder.AddFloat(0, x, 0.0f); }
  public static void AddY(FlatBufferBuilder builder, float y) { builder.AddFloat(1, y, 0.0f); }
  public static void AddZ(FlatBufferBuilder builder, float z) { builder.AddFloat(2, z, 0.0f); }
  public static Offset<gfl.anm2.fbj.Vector3> EndVector3(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fbj.Vector3>(o);
  }
  public Vector3T UnPack() {
    var _o = new Vector3T();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(Vector3T _o) {
    _o.X = this.X;
    _o.Y = this.Y;
    _o.Z = this.Z;
  }
  public static Offset<gfl.anm2.fbj.Vector3> Pack(FlatBufferBuilder builder, Vector3T _o) {
    if (_o == null) return default(Offset<gfl.anm2.fbj.Vector3>);
    return CreateVector3(
      builder,
      _o.X,
      _o.Y,
      _o.Z);
  }
};

public class Vector3T
{
  [Newtonsoft.Json.JsonProperty("x")]
  public float X { get; set; }
  [Newtonsoft.Json.JsonProperty("y")]
  public float Y { get; set; }
  [Newtonsoft.Json.JsonProperty("z")]
  public float Z { get; set; }

  public Vector3T() {
    this.X = 0.0f;
    this.Y = 0.0f;
    this.Z = 0.0f;
  }
}

public struct SRT : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static SRT GetRootAsSRT(ByteBuffer _bb) { return GetRootAsSRT(_bb, new SRT()); }
  public static SRT GetRootAsSRT(ByteBuffer _bb, SRT obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SRT __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public gfl.anm2.fbj.Vector3? Scale { get { int o = __p.__offset(4); return o != 0 ? (gfl.anm2.fbj.Vector3?)(new gfl.anm2.fbj.Vector3()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public gfl.anm2.fbj.Vector3? Rotate { get { int o = __p.__offset(6); return o != 0 ? (gfl.anm2.fbj.Vector3?)(new gfl.anm2.fbj.Vector3()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public gfl.anm2.fbj.Vector3? Translate { get { int o = __p.__offset(8); return o != 0 ? (gfl.anm2.fbj.Vector3?)(new gfl.anm2.fbj.Vector3()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }

  public static Offset<gfl.anm2.fbj.SRT> CreateSRT(FlatBufferBuilder builder,
      Offset<gfl.anm2.fbj.Vector3> scaleOffset = default(Offset<gfl.anm2.fbj.Vector3>),
      Offset<gfl.anm2.fbj.Vector3> rotateOffset = default(Offset<gfl.anm2.fbj.Vector3>),
      Offset<gfl.anm2.fbj.Vector3> translateOffset = default(Offset<gfl.anm2.fbj.Vector3>)) {
    builder.StartTable(3);
    SRT.AddTranslate(builder, translateOffset);
    SRT.AddRotate(builder, rotateOffset);
    SRT.AddScale(builder, scaleOffset);
    return SRT.EndSRT(builder);
  }

  public static void StartSRT(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddScale(FlatBufferBuilder builder, Offset<gfl.anm2.fbj.Vector3> scaleOffset) { builder.AddOffset(0, scaleOffset.Value, 0); }
  public static void AddRotate(FlatBufferBuilder builder, Offset<gfl.anm2.fbj.Vector3> rotateOffset) { builder.AddOffset(1, rotateOffset.Value, 0); }
  public static void AddTranslate(FlatBufferBuilder builder, Offset<gfl.anm2.fbj.Vector3> translateOffset) { builder.AddOffset(2, translateOffset.Value, 0); }
  public static Offset<gfl.anm2.fbj.SRT> EndSRT(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fbj.SRT>(o);
  }
  public SRTT UnPack() {
    var _o = new SRTT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(SRTT _o) {
    _o.Scale = this.Scale.HasValue ? this.Scale.Value.UnPack() : null;
    _o.Rotate = this.Rotate.HasValue ? this.Rotate.Value.UnPack() : null;
    _o.Translate = this.Translate.HasValue ? this.Translate.Value.UnPack() : null;
  }
  public static Offset<gfl.anm2.fbj.SRT> Pack(FlatBufferBuilder builder, SRTT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fbj.SRT>);
    var _scale = _o.Scale == null ? default(Offset<gfl.anm2.fbj.Vector3>) : gfl.anm2.fbj.Vector3.Pack(builder, _o.Scale);
    var _rotate = _o.Rotate == null ? default(Offset<gfl.anm2.fbj.Vector3>) : gfl.anm2.fbj.Vector3.Pack(builder, _o.Rotate);
    var _translate = _o.Translate == null ? default(Offset<gfl.anm2.fbj.Vector3>) : gfl.anm2.fbj.Vector3.Pack(builder, _o.Translate);
    return CreateSRT(
      builder,
      _scale,
      _rotate,
      _translate);
  }
};

public class SRTT
{
  [Newtonsoft.Json.JsonProperty("scale")]
  public gfl.anm2.fbj.Vector3T Scale { get; set; }
  [Newtonsoft.Json.JsonProperty("rotate")]
  public gfl.anm2.fbj.Vector3T Rotate { get; set; }
  [Newtonsoft.Json.JsonProperty("translate")]
  public gfl.anm2.fbj.Vector3T Translate { get; set; }

  public SRTT() {
    this.Scale = null;
    this.Rotate = null;
    this.Translate = null;
  }
}

public struct BoolKey : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static BoolKey GetRootAsBoolKey(ByteBuffer _bb) { return GetRootAsBoolKey(_bb, new BoolKey()); }
  public static BoolKey GetRootAsBoolKey(ByteBuffer _bb, BoolKey obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BoolKey __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int Frame { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public bool Value { get { int o = __p.__offset(6); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<gfl.anm2.fbj.BoolKey> CreateBoolKey(FlatBufferBuilder builder,
      int frame = 0,
      bool value = false) {
    builder.StartTable(2);
    BoolKey.AddFrame(builder, frame);
    BoolKey.AddValue(builder, value);
    return BoolKey.EndBoolKey(builder);
  }

  public static void StartBoolKey(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddFrame(FlatBufferBuilder builder, int frame) { builder.AddInt(0, frame, 0); }
  public static void AddValue(FlatBufferBuilder builder, bool value) { builder.AddBool(1, value, false); }
  public static Offset<gfl.anm2.fbj.BoolKey> EndBoolKey(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fbj.BoolKey>(o);
  }
  public BoolKeyT UnPack() {
    var _o = new BoolKeyT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(BoolKeyT _o) {
    _o.Frame = this.Frame;
    _o.Value = this.Value;
  }
  public static Offset<gfl.anm2.fbj.BoolKey> Pack(FlatBufferBuilder builder, BoolKeyT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fbj.BoolKey>);
    return CreateBoolKey(
      builder,
      _o.Frame,
      _o.Value);
  }
};

public class BoolKeyT
{
  [Newtonsoft.Json.JsonProperty("frame")]
  public int Frame { get; set; }
  [Newtonsoft.Json.JsonProperty("value")]
  public bool Value { get; set; }

  public BoolKeyT() {
    this.Frame = 0;
    this.Value = false;
  }
}

public struct DoubleKey : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static DoubleKey GetRootAsDoubleKey(ByteBuffer _bb) { return GetRootAsDoubleKey(_bb, new DoubleKey()); }
  public static DoubleKey GetRootAsDoubleKey(ByteBuffer _bb, DoubleKey obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public DoubleKey __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int Frame { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public double Value { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }

  public static Offset<gfl.anm2.fbj.DoubleKey> CreateDoubleKey(FlatBufferBuilder builder,
      int frame = 0,
      double value = 0.0) {
    builder.StartTable(2);
    DoubleKey.AddValue(builder, value);
    DoubleKey.AddFrame(builder, frame);
    return DoubleKey.EndDoubleKey(builder);
  }

  public static void StartDoubleKey(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddFrame(FlatBufferBuilder builder, int frame) { builder.AddInt(0, frame, 0); }
  public static void AddValue(FlatBufferBuilder builder, double value) { builder.AddDouble(1, value, 0.0); }
  public static Offset<gfl.anm2.fbj.DoubleKey> EndDoubleKey(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fbj.DoubleKey>(o);
  }
  public DoubleKeyT UnPack() {
    var _o = new DoubleKeyT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(DoubleKeyT _o) {
    _o.Frame = this.Frame;
    _o.Value = this.Value;
  }
  public static Offset<gfl.anm2.fbj.DoubleKey> Pack(FlatBufferBuilder builder, DoubleKeyT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fbj.DoubleKey>);
    return CreateDoubleKey(
      builder,
      _o.Frame,
      _o.Value);
  }
};

public class DoubleKeyT
{
  [Newtonsoft.Json.JsonProperty("frame")]
  public int Frame { get; set; }
  [Newtonsoft.Json.JsonProperty("value")]
  public double Value { get; set; }

  public DoubleKeyT() {
    this.Frame = 0;
    this.Value = 0.0;
  }
}

public struct HermiteKey : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static HermiteKey GetRootAsHermiteKey(ByteBuffer _bb) { return GetRootAsHermiteKey(_bb, new HermiteKey()); }
  public static HermiteKey GetRootAsHermiteKey(ByteBuffer _bb, HermiteKey obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public HermiteKey __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int Frame { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public double Value { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  public double Slope { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }

  public static Offset<gfl.anm2.fbj.HermiteKey> CreateHermiteKey(FlatBufferBuilder builder,
      int frame = 0,
      double value = 0.0,
      double slope = 0.0) {
    builder.StartTable(3);
    HermiteKey.AddSlope(builder, slope);
    HermiteKey.AddValue(builder, value);
    HermiteKey.AddFrame(builder, frame);
    return HermiteKey.EndHermiteKey(builder);
  }

  public static void StartHermiteKey(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddFrame(FlatBufferBuilder builder, int frame) { builder.AddInt(0, frame, 0); }
  public static void AddValue(FlatBufferBuilder builder, double value) { builder.AddDouble(1, value, 0.0); }
  public static void AddSlope(FlatBufferBuilder builder, double slope) { builder.AddDouble(2, slope, 0.0); }
  public static Offset<gfl.anm2.fbj.HermiteKey> EndHermiteKey(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fbj.HermiteKey>(o);
  }
  public HermiteKeyT UnPack() {
    var _o = new HermiteKeyT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(HermiteKeyT _o) {
    _o.Frame = this.Frame;
    _o.Value = this.Value;
    _o.Slope = this.Slope;
  }
  public static Offset<gfl.anm2.fbj.HermiteKey> Pack(FlatBufferBuilder builder, HermiteKeyT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fbj.HermiteKey>);
    return CreateHermiteKey(
      builder,
      _o.Frame,
      _o.Value,
      _o.Slope);
  }
};

public class HermiteKeyT
{
  [Newtonsoft.Json.JsonProperty("frame")]
  public int Frame { get; set; }
  [Newtonsoft.Json.JsonProperty("value")]
  public double Value { get; set; }
  [Newtonsoft.Json.JsonProperty("slope")]
  public double Slope { get; set; }

  public HermiteKeyT() {
    this.Frame = 0;
    this.Value = 0.0;
    this.Slope = 0.0;
  }
}

public struct KeyBase : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static KeyBase GetRootAsKeyBase(ByteBuffer _bb) { return GetRootAsKeyBase(_bb, new KeyBase()); }
  public static KeyBase GetRootAsKeyBase(ByteBuffer _bb, KeyBase obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public KeyBase __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public gfl.anm2.fbj.KeyType KeyType { get { int o = __p.__offset(4); return o != 0 ? (gfl.anm2.fbj.KeyType)__p.bb.Get(o + __p.bb_pos) : gfl.anm2.fbj.KeyType.NONE; } }
  public TTable? Key<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(6); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }

  public static Offset<gfl.anm2.fbj.KeyBase> CreateKeyBase(FlatBufferBuilder builder,
      gfl.anm2.fbj.KeyType key_type = gfl.anm2.fbj.KeyType.NONE,
      int keyOffset = 0) {
    builder.StartTable(2);
    KeyBase.AddKey(builder, keyOffset);
    KeyBase.AddKeyType(builder, key_type);
    return KeyBase.EndKeyBase(builder);
  }

  public static void StartKeyBase(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddKeyType(FlatBufferBuilder builder, gfl.anm2.fbj.KeyType keyType) { builder.AddByte(0, (byte)keyType, 0); }
  public static void AddKey(FlatBufferBuilder builder, int keyOffset) { builder.AddOffset(1, keyOffset, 0); }
  public static Offset<gfl.anm2.fbj.KeyBase> EndKeyBase(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fbj.KeyBase>(o);
  }
  public KeyBaseT UnPack() {
    var _o = new KeyBaseT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(KeyBaseT _o) {
    _o.Key = new gfl.anm2.fbj.KeyTypeUnion();
    _o.Key.Type = this.KeyType;
    switch (this.KeyType) {
      default: break;
      case gfl.anm2.fbj.KeyType.BoolKey:
        _o.Key.Value = this.Key<gfl.anm2.fbj.BoolKey>().HasValue ? this.Key<gfl.anm2.fbj.BoolKey>().Value.UnPack() : null;
        break;
      case gfl.anm2.fbj.KeyType.DoubleKey:
        _o.Key.Value = this.Key<gfl.anm2.fbj.DoubleKey>().HasValue ? this.Key<gfl.anm2.fbj.DoubleKey>().Value.UnPack() : null;
        break;
      case gfl.anm2.fbj.KeyType.HermiteKey:
        _o.Key.Value = this.Key<gfl.anm2.fbj.HermiteKey>().HasValue ? this.Key<gfl.anm2.fbj.HermiteKey>().Value.UnPack() : null;
        break;
    }
  }
  public static Offset<gfl.anm2.fbj.KeyBase> Pack(FlatBufferBuilder builder, KeyBaseT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fbj.KeyBase>);
    var _key_type = _o.Key == null ? gfl.anm2.fbj.KeyType.NONE : _o.Key.Type;
    var _key = _o.Key == null ? 0 : gfl.anm2.fbj.KeyTypeUnion.Pack(builder, _o.Key);
    return CreateKeyBase(
      builder,
      _key_type,
      _key);
  }
};

public class KeyBaseT
{
  [Newtonsoft.Json.JsonProperty("key_type")]
  private gfl.anm2.fbj.KeyType KeyType {
    get {
      return this.Key != null ? this.Key.Type : gfl.anm2.fbj.KeyType.NONE;
    }
    set {
      this.Key = new gfl.anm2.fbj.KeyTypeUnion();
      this.Key.Type = value;
    }
  }
  [Newtonsoft.Json.JsonProperty("key")]
  [Newtonsoft.Json.JsonConverter(typeof(gfl.anm2.fbj.KeyTypeUnion_JsonConverter))]
  public gfl.anm2.fbj.KeyTypeUnion Key { get; set; }

  public KeyBaseT() {
    this.Key = null;
  }
}


}
