// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace gfl.anm2.fb
{

using global::System;
using global::System.Collections.Generic;
using global::FlatBuffers;

public struct CurveData : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static CurveData GetRootAsCurveData(ByteBuffer _bb) { return GetRootAsCurveData(_bb, new CurveData()); }
  public static CurveData GetRootAsCurveData(ByteBuffer _bb, CurveData obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public CurveData __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public gfl.anm2.fb.EditorCurveType EditorCurveType { get { int o = __p.__offset(4); return o != 0 ? (gfl.anm2.fb.EditorCurveType)__p.bb.Get(o + __p.bb_pos) : gfl.anm2.fb.EditorCurveType.NONE; } }
  public TTable? EditorCurve<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(6); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }
  public gfl.anm2.fb.RuntimeCurveType RuntimeCurveType { get { int o = __p.__offset(8); return o != 0 ? (gfl.anm2.fb.RuntimeCurveType)__p.bb.Get(o + __p.bb_pos) : gfl.anm2.fb.RuntimeCurveType.NONE; } }
  public TTable? RuntimeCurve<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(10); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }

  public static Offset<gfl.anm2.fb.CurveData> CreateCurveData(FlatBufferBuilder builder,
      gfl.anm2.fb.EditorCurveType editorCurve_type = gfl.anm2.fb.EditorCurveType.NONE,
      int editorCurveOffset = 0,
      gfl.anm2.fb.RuntimeCurveType runtimeCurve_type = gfl.anm2.fb.RuntimeCurveType.NONE,
      int runtimeCurveOffset = 0) {
    builder.StartTable(4);
    CurveData.AddRuntimeCurve(builder, runtimeCurveOffset);
    CurveData.AddEditorCurve(builder, editorCurveOffset);
    CurveData.AddRuntimeCurveType(builder, runtimeCurve_type);
    CurveData.AddEditorCurveType(builder, editorCurve_type);
    return CurveData.EndCurveData(builder);
  }

  public static void StartCurveData(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddEditorCurveType(FlatBufferBuilder builder, gfl.anm2.fb.EditorCurveType editorCurveType) { builder.AddByte(0, (byte)editorCurveType, 0); }
  public static void AddEditorCurve(FlatBufferBuilder builder, int editorCurveOffset) { builder.AddOffset(1, editorCurveOffset, 0); }
  public static void AddRuntimeCurveType(FlatBufferBuilder builder, gfl.anm2.fb.RuntimeCurveType runtimeCurveType) { builder.AddByte(2, (byte)runtimeCurveType, 0); }
  public static void AddRuntimeCurve(FlatBufferBuilder builder, int runtimeCurveOffset) { builder.AddOffset(3, runtimeCurveOffset, 0); }
  public static Offset<gfl.anm2.fb.CurveData> EndCurveData(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fb.CurveData>(o);
  }
  public static void FinishCurveDataBuffer(FlatBufferBuilder builder, Offset<gfl.anm2.fb.CurveData> offset) { builder.Finish(offset.Value); }
  public static void FinishSizePrefixedCurveDataBuffer(FlatBufferBuilder builder, Offset<gfl.anm2.fb.CurveData> offset) { builder.FinishSizePrefixed(offset.Value); }
  public CurveDataT UnPack() {
    var _o = new CurveDataT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(CurveDataT _o) {
    _o.EditorCurve = new gfl.anm2.fb.EditorCurveTypeUnion();
    _o.EditorCurve.Type = this.EditorCurveType;
    switch (this.EditorCurveType) {
      default: break;
      case gfl.anm2.fb.EditorCurveType.EditorCurveFloat:
        _o.EditorCurve.Value = this.EditorCurve<gfl.anm2.fb.EditorCurveFloat>().HasValue ? this.EditorCurve<gfl.anm2.fb.EditorCurveFloat>().Value.UnPack() : null;
        break;
      case gfl.anm2.fb.EditorCurveType.EditorCurveFloat4:
        _o.EditorCurve.Value = this.EditorCurve<gfl.anm2.fb.EditorCurveFloat4>().HasValue ? this.EditorCurve<gfl.anm2.fb.EditorCurveFloat4>().Value.UnPack() : null;
        break;
    }
    _o.RuntimeCurve = new gfl.anm2.fb.RuntimeCurveTypeUnion();
    _o.RuntimeCurve.Type = this.RuntimeCurveType;
    switch (this.RuntimeCurveType) {
      default: break;
      case gfl.anm2.fb.RuntimeCurveType.RuntimeCurveFloat:
        _o.RuntimeCurve.Value = this.RuntimeCurve<gfl.anm2.fb.RuntimeCurveFloat>().HasValue ? this.RuntimeCurve<gfl.anm2.fb.RuntimeCurveFloat>().Value.UnPack() : null;
        break;
      case gfl.anm2.fb.RuntimeCurveType.RuntimeCurveFloat4:
        _o.RuntimeCurve.Value = this.RuntimeCurve<gfl.anm2.fb.RuntimeCurveFloat4>().HasValue ? this.RuntimeCurve<gfl.anm2.fb.RuntimeCurveFloat4>().Value.UnPack() : null;
        break;
    }
  }
  public static Offset<gfl.anm2.fb.CurveData> Pack(FlatBufferBuilder builder, CurveDataT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fb.CurveData>);
    var _editorCurve_type = _o.EditorCurve == null ? gfl.anm2.fb.EditorCurveType.NONE : _o.EditorCurve.Type;
    var _editorCurve = _o.EditorCurve == null ? 0 : gfl.anm2.fb.EditorCurveTypeUnion.Pack(builder, _o.EditorCurve);
    var _runtimeCurve_type = _o.RuntimeCurve == null ? gfl.anm2.fb.RuntimeCurveType.NONE : _o.RuntimeCurve.Type;
    var _runtimeCurve = _o.RuntimeCurve == null ? 0 : gfl.anm2.fb.RuntimeCurveTypeUnion.Pack(builder, _o.RuntimeCurve);
    return CreateCurveData(
      builder,
      _editorCurve_type,
      _editorCurve,
      _runtimeCurve_type,
      _runtimeCurve);
  }
};

public class CurveDataT
{
  [Newtonsoft.Json.JsonProperty("editorCurve_type")]
  private gfl.anm2.fb.EditorCurveType EditorCurveType {
    get {
      return this.EditorCurve != null ? this.EditorCurve.Type : gfl.anm2.fb.EditorCurveType.NONE;
    }
    set {
      this.EditorCurve = new gfl.anm2.fb.EditorCurveTypeUnion();
      this.EditorCurve.Type = value;
    }
  }
  [Newtonsoft.Json.JsonProperty("editorCurve")]
  [Newtonsoft.Json.JsonConverter(typeof(gfl.anm2.fb.EditorCurveTypeUnion_JsonConverter))]
  public gfl.anm2.fb.EditorCurveTypeUnion EditorCurve { get; set; }
  [Newtonsoft.Json.JsonProperty("runtimeCurve_type")]
  private gfl.anm2.fb.RuntimeCurveType RuntimeCurveType {
    get {
      return this.RuntimeCurve != null ? this.RuntimeCurve.Type : gfl.anm2.fb.RuntimeCurveType.NONE;
    }
    set {
      this.RuntimeCurve = new gfl.anm2.fb.RuntimeCurveTypeUnion();
      this.RuntimeCurve.Type = value;
    }
  }
  [Newtonsoft.Json.JsonProperty("runtimeCurve")]
  [Newtonsoft.Json.JsonConverter(typeof(gfl.anm2.fb.RuntimeCurveTypeUnion_JsonConverter))]
  public gfl.anm2.fb.RuntimeCurveTypeUnion RuntimeCurve { get; set; }

  public CurveDataT() {
    this.EditorCurve = null;
    this.RuntimeCurve = null;
  }

  public static CurveDataT DeserializeFromJson(string jsonText) {
    return Newtonsoft.Json.JsonConvert.DeserializeObject<CurveDataT>(jsonText);
  }
  public string SerializeToJson() {
    return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
  }
  public static CurveDataT DeserializeFromBinary(byte[] fbBuffer) {
    return CurveData.GetRootAsCurveData(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    CurveData.FinishCurveDataBuffer(fbb, CurveData.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


}
