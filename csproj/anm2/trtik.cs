// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace gfl.anm2.fb
{

using global::System;
using global::System.Collections.Generic;
using global::FlatBuffers;

public struct Vector : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public Vector __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float X { get { return __p.bb.GetFloat(__p.bb_pos + 0); } }
  public float Y { get { return __p.bb.GetFloat(__p.bb_pos + 4); } }
  public float Z { get { return __p.bb.GetFloat(__p.bb_pos + 8); } }

  public static Offset<gfl.anm2.fb.Vector> CreateVector(FlatBufferBuilder builder, float X, float Y, float Z) {
    builder.Prep(4, 12);
    builder.PutFloat(Z);
    builder.PutFloat(Y);
    builder.PutFloat(X);
    return new Offset<gfl.anm2.fb.Vector>(builder.Offset);
  }
  public VectorT UnPack() {
    var _o = new VectorT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(VectorT _o) {
    _o.X = this.X;
    _o.Y = this.Y;
    _o.Z = this.Z;
  }
  public static Offset<gfl.anm2.fb.Vector> Pack(FlatBufferBuilder builder, VectorT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fb.Vector>);
    return CreateVector(
      builder,
      _o.X,
      _o.Y,
      _o.Z);
  }
};

public class VectorT
{
  [Newtonsoft.Json.JsonProperty("x")]
  public float X { get; set; }
  [Newtonsoft.Json.JsonProperty("y")]
  public float Y { get; set; }
  [Newtonsoft.Json.JsonProperty("z")]
  public float Z { get; set; }

  public VectorT() {
    this.X = 0.0f;
    this.Y = 0.0f;
    this.Z = 0.0f;
  }
}

public struct ToeSolverData : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static ToeSolverData GetRootAsToeSolverData(ByteBuffer _bb) { return GetRootAsToeSolverData(_bb, new ToeSolverData()); }
  public static ToeSolverData GetRootAsToeSolverData(ByteBuffer _bb, ToeSolverData obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ToeSolverData __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public bool IsEnabled { get { int o = __p.__offset(4); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public float Factor { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public gfl.anm2.fb.Vector? GroundNormal { get { int o = __p.__offset(8); return o != 0 ? (gfl.anm2.fb.Vector?)(new gfl.anm2.fb.Vector()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public gfl.anm2.fb.Vector? LocalForward { get { int o = __p.__offset(10); return o != 0 ? (gfl.anm2.fb.Vector?)(new gfl.anm2.fb.Vector()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public gfl.anm2.fb.Vector? LocalUp { get { int o = __p.__offset(12); return o != 0 ? (gfl.anm2.fb.Vector?)(new gfl.anm2.fb.Vector()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public bool ConstraintIsEnabled { get { int o = __p.__offset(14); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public float FwdPositive { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float FwdNegative { get { int o = __p.__offset(18); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float SidePositive { get { int o = __p.__offset(20); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float SideNegative { get { int o = __p.__offset(22); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<gfl.anm2.fb.ToeSolverData> CreateToeSolverData(FlatBufferBuilder builder,
      bool isEnabled = false,
      float factor = 0.0f,
      gfl.anm2.fb.VectorT groundNormal = null,
      gfl.anm2.fb.VectorT localForward = null,
      gfl.anm2.fb.VectorT localUp = null,
      bool constraintIsEnabled = false,
      float fwd_Positive = 0.0f,
      float fwd_Negative = 0.0f,
      float side_Positive = 0.0f,
      float side_Negative = 0.0f) {
    builder.StartTable(10);
    ToeSolverData.AddSideNegative(builder, side_Negative);
    ToeSolverData.AddSidePositive(builder, side_Positive);
    ToeSolverData.AddFwdNegative(builder, fwd_Negative);
    ToeSolverData.AddFwdPositive(builder, fwd_Positive);
    ToeSolverData.AddLocalUp(builder, gfl.anm2.fb.Vector.Pack(builder, localUp));
    ToeSolverData.AddLocalForward(builder, gfl.anm2.fb.Vector.Pack(builder, localForward));
    ToeSolverData.AddGroundNormal(builder, gfl.anm2.fb.Vector.Pack(builder, groundNormal));
    ToeSolverData.AddFactor(builder, factor);
    ToeSolverData.AddConstraintIsEnabled(builder, constraintIsEnabled);
    ToeSolverData.AddIsEnabled(builder, isEnabled);
    return ToeSolverData.EndToeSolverData(builder);
  }

  public static void StartToeSolverData(FlatBufferBuilder builder) { builder.StartTable(10); }
  public static void AddIsEnabled(FlatBufferBuilder builder, bool isEnabled) { builder.AddBool(0, isEnabled, false); }
  public static void AddFactor(FlatBufferBuilder builder, float factor) { builder.AddFloat(1, factor, 0.0f); }
  public static void AddGroundNormal(FlatBufferBuilder builder, Offset<gfl.anm2.fb.Vector> groundNormalOffset) { builder.AddStruct(2, groundNormalOffset.Value, 0); }
  public static void AddLocalForward(FlatBufferBuilder builder, Offset<gfl.anm2.fb.Vector> localForwardOffset) { builder.AddStruct(3, localForwardOffset.Value, 0); }
  public static void AddLocalUp(FlatBufferBuilder builder, Offset<gfl.anm2.fb.Vector> localUpOffset) { builder.AddStruct(4, localUpOffset.Value, 0); }
  public static void AddConstraintIsEnabled(FlatBufferBuilder builder, bool constraintIsEnabled) { builder.AddBool(5, constraintIsEnabled, false); }
  public static void AddFwdPositive(FlatBufferBuilder builder, float fwdPositive) { builder.AddFloat(6, fwdPositive, 0.0f); }
  public static void AddFwdNegative(FlatBufferBuilder builder, float fwdNegative) { builder.AddFloat(7, fwdNegative, 0.0f); }
  public static void AddSidePositive(FlatBufferBuilder builder, float sidePositive) { builder.AddFloat(8, sidePositive, 0.0f); }
  public static void AddSideNegative(FlatBufferBuilder builder, float sideNegative) { builder.AddFloat(9, sideNegative, 0.0f); }
  public static Offset<gfl.anm2.fb.ToeSolverData> EndToeSolverData(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fb.ToeSolverData>(o);
  }
  public ToeSolverDataT UnPack() {
    var _o = new ToeSolverDataT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(ToeSolverDataT _o) {
    _o.IsEnabled = this.IsEnabled;
    _o.Factor = this.Factor;
    _o.GroundNormal = this.GroundNormal.HasValue ? this.GroundNormal.Value.UnPack() : null;
    _o.LocalForward = this.LocalForward.HasValue ? this.LocalForward.Value.UnPack() : null;
    _o.LocalUp = this.LocalUp.HasValue ? this.LocalUp.Value.UnPack() : null;
    _o.ConstraintIsEnabled = this.ConstraintIsEnabled;
    _o.FwdPositive = this.FwdPositive;
    _o.FwdNegative = this.FwdNegative;
    _o.SidePositive = this.SidePositive;
    _o.SideNegative = this.SideNegative;
  }
  public static Offset<gfl.anm2.fb.ToeSolverData> Pack(FlatBufferBuilder builder, ToeSolverDataT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fb.ToeSolverData>);
    return CreateToeSolverData(
      builder,
      _o.IsEnabled,
      _o.Factor,
      _o.GroundNormal,
      _o.LocalForward,
      _o.LocalUp,
      _o.ConstraintIsEnabled,
      _o.FwdPositive,
      _o.FwdNegative,
      _o.SidePositive,
      _o.SideNegative);
  }
};

public class ToeSolverDataT
{
  [Newtonsoft.Json.JsonProperty("isEnabled")]
  public bool IsEnabled { get; set; }
  [Newtonsoft.Json.JsonProperty("factor")]
  public float Factor { get; set; }
  [Newtonsoft.Json.JsonProperty("groundNormal")]
  public gfl.anm2.fb.VectorT GroundNormal { get; set; }
  [Newtonsoft.Json.JsonProperty("localForward")]
  public gfl.anm2.fb.VectorT LocalForward { get; set; }
  [Newtonsoft.Json.JsonProperty("localUp")]
  public gfl.anm2.fb.VectorT LocalUp { get; set; }
  [Newtonsoft.Json.JsonProperty("constraintIsEnabled")]
  public bool ConstraintIsEnabled { get; set; }
  [Newtonsoft.Json.JsonProperty("fwd_Positive")]
  public float FwdPositive { get; set; }
  [Newtonsoft.Json.JsonProperty("fwd_Negative")]
  public float FwdNegative { get; set; }
  [Newtonsoft.Json.JsonProperty("side_Positive")]
  public float SidePositive { get; set; }
  [Newtonsoft.Json.JsonProperty("side_Negative")]
  public float SideNegative { get; set; }

  public ToeSolverDataT() {
    this.IsEnabled = false;
    this.Factor = 0.0f;
    this.GroundNormal = new gfl.anm2.fb.VectorT();
    this.LocalForward = new gfl.anm2.fb.VectorT();
    this.LocalUp = new gfl.anm2.fb.VectorT();
    this.ConstraintIsEnabled = false;
    this.FwdPositive = 0.0f;
    this.FwdNegative = 0.0f;
    this.SidePositive = 0.0f;
    this.SideNegative = 0.0f;
  }
}

public struct TwoBoneIKSetData : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static TwoBoneIKSetData GetRootAsTwoBoneIKSetData(ByteBuffer _bb) { return GetRootAsTwoBoneIKSetData(_bb, new TwoBoneIKSetData()); }
  public static TwoBoneIKSetData GetRootAsTwoBoneIKSetData(ByteBuffer _bb, TwoBoneIKSetData obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public TwoBoneIKSetData __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public bool IsEnabled { get { int o = __p.__offset(4); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public string RootNodeName { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetRootNodeNameBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetRootNodeNameBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetRootNodeNameArray() { return __p.__vector_as_array<byte>(6); }
  public string MiddleNodeName { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMiddleNodeNameBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetMiddleNodeNameBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetMiddleNodeNameArray() { return __p.__vector_as_array<byte>(8); }
  public string TipNodeName { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTipNodeNameBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetTipNodeNameBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetTipNodeNameArray() { return __p.__vector_as_array<byte>(10); }
  public bool RootConstraintIsEnabled { get { int o = __p.__offset(12); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public float RootConstraintRangeAxisYPositive { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float RootConstraintRangeAxisYNegative { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float RootConstraintRangeAxisZPositive { get { int o = __p.__offset(18); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float RootConstraintRangeAxisZNegative { get { int o = __p.__offset(20); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public int RootConstraintIterations { get { int o = __p.__offset(22); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public bool MiddleConstraintIsEnabled { get { int o = __p.__offset(24); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public float MiddleConstraintRangePositive { get { int o = __p.__offset(26); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float MiddleConstraintRangeNegative { get { int o = __p.__offset(28); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public gfl.anm2.fb.Vector? PoleVector { get { int o = __p.__offset(30); return o != 0 ? (gfl.anm2.fb.Vector?)(new gfl.anm2.fb.Vector()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public float Twist { get { int o = __p.__offset(32); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float Weight { get { int o = __p.__offset(34); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public gfl.anm2.fb.ToeSolverData? ToeSolverData { get { int o = __p.__offset(36); return o != 0 ? (gfl.anm2.fb.ToeSolverData?)(new gfl.anm2.fb.ToeSolverData()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public bool TargetOffsetIsEnabled { get { int o = __p.__offset(38); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<gfl.anm2.fb.TwoBoneIKSetData> CreateTwoBoneIKSetData(FlatBufferBuilder builder,
      bool isEnabled = false,
      StringOffset rootNodeNameOffset = default(StringOffset),
      StringOffset middleNodeNameOffset = default(StringOffset),
      StringOffset tipNodeNameOffset = default(StringOffset),
      bool rootConstraintIsEnabled = false,
      float rootConstraintRangeAxisY_Positive = 0.0f,
      float rootConstraintRangeAxisY_Negative = 0.0f,
      float rootConstraintRangeAxisZ_Positive = 0.0f,
      float rootConstraintRangeAxisZ_Negative = 0.0f,
      int rootConstraintIterations = 0,
      bool middleConstraintIsEnabled = false,
      float middleConstraintRange_Positive = 0.0f,
      float middleConstraintRange_Negative = 0.0f,
      gfl.anm2.fb.VectorT poleVector = null,
      float twist = 0.0f,
      float weight = 0.0f,
      Offset<gfl.anm2.fb.ToeSolverData> toeSolverDataOffset = default(Offset<gfl.anm2.fb.ToeSolverData>),
      bool targetOffsetIsEnabled = false) {
    builder.StartTable(18);
    TwoBoneIKSetData.AddToeSolverData(builder, toeSolverDataOffset);
    TwoBoneIKSetData.AddWeight(builder, weight);
    TwoBoneIKSetData.AddTwist(builder, twist);
    TwoBoneIKSetData.AddPoleVector(builder, gfl.anm2.fb.Vector.Pack(builder, poleVector));
    TwoBoneIKSetData.AddMiddleConstraintRangeNegative(builder, middleConstraintRange_Negative);
    TwoBoneIKSetData.AddMiddleConstraintRangePositive(builder, middleConstraintRange_Positive);
    TwoBoneIKSetData.AddRootConstraintIterations(builder, rootConstraintIterations);
    TwoBoneIKSetData.AddRootConstraintRangeAxisZNegative(builder, rootConstraintRangeAxisZ_Negative);
    TwoBoneIKSetData.AddRootConstraintRangeAxisZPositive(builder, rootConstraintRangeAxisZ_Positive);
    TwoBoneIKSetData.AddRootConstraintRangeAxisYNegative(builder, rootConstraintRangeAxisY_Negative);
    TwoBoneIKSetData.AddRootConstraintRangeAxisYPositive(builder, rootConstraintRangeAxisY_Positive);
    TwoBoneIKSetData.AddTipNodeName(builder, tipNodeNameOffset);
    TwoBoneIKSetData.AddMiddleNodeName(builder, middleNodeNameOffset);
    TwoBoneIKSetData.AddRootNodeName(builder, rootNodeNameOffset);
    TwoBoneIKSetData.AddTargetOffsetIsEnabled(builder, targetOffsetIsEnabled);
    TwoBoneIKSetData.AddMiddleConstraintIsEnabled(builder, middleConstraintIsEnabled);
    TwoBoneIKSetData.AddRootConstraintIsEnabled(builder, rootConstraintIsEnabled);
    TwoBoneIKSetData.AddIsEnabled(builder, isEnabled);
    return TwoBoneIKSetData.EndTwoBoneIKSetData(builder);
  }

  public static void StartTwoBoneIKSetData(FlatBufferBuilder builder) { builder.StartTable(18); }
  public static void AddIsEnabled(FlatBufferBuilder builder, bool isEnabled) { builder.AddBool(0, isEnabled, false); }
  public static void AddRootNodeName(FlatBufferBuilder builder, StringOffset rootNodeNameOffset) { builder.AddOffset(1, rootNodeNameOffset.Value, 0); }
  public static void AddMiddleNodeName(FlatBufferBuilder builder, StringOffset middleNodeNameOffset) { builder.AddOffset(2, middleNodeNameOffset.Value, 0); }
  public static void AddTipNodeName(FlatBufferBuilder builder, StringOffset tipNodeNameOffset) { builder.AddOffset(3, tipNodeNameOffset.Value, 0); }
  public static void AddRootConstraintIsEnabled(FlatBufferBuilder builder, bool rootConstraintIsEnabled) { builder.AddBool(4, rootConstraintIsEnabled, false); }
  public static void AddRootConstraintRangeAxisYPositive(FlatBufferBuilder builder, float rootConstraintRangeAxisYPositive) { builder.AddFloat(5, rootConstraintRangeAxisYPositive, 0.0f); }
  public static void AddRootConstraintRangeAxisYNegative(FlatBufferBuilder builder, float rootConstraintRangeAxisYNegative) { builder.AddFloat(6, rootConstraintRangeAxisYNegative, 0.0f); }
  public static void AddRootConstraintRangeAxisZPositive(FlatBufferBuilder builder, float rootConstraintRangeAxisZPositive) { builder.AddFloat(7, rootConstraintRangeAxisZPositive, 0.0f); }
  public static void AddRootConstraintRangeAxisZNegative(FlatBufferBuilder builder, float rootConstraintRangeAxisZNegative) { builder.AddFloat(8, rootConstraintRangeAxisZNegative, 0.0f); }
  public static void AddRootConstraintIterations(FlatBufferBuilder builder, int rootConstraintIterations) { builder.AddInt(9, rootConstraintIterations, 0); }
  public static void AddMiddleConstraintIsEnabled(FlatBufferBuilder builder, bool middleConstraintIsEnabled) { builder.AddBool(10, middleConstraintIsEnabled, false); }
  public static void AddMiddleConstraintRangePositive(FlatBufferBuilder builder, float middleConstraintRangePositive) { builder.AddFloat(11, middleConstraintRangePositive, 0.0f); }
  public static void AddMiddleConstraintRangeNegative(FlatBufferBuilder builder, float middleConstraintRangeNegative) { builder.AddFloat(12, middleConstraintRangeNegative, 0.0f); }
  public static void AddPoleVector(FlatBufferBuilder builder, Offset<gfl.anm2.fb.Vector> poleVectorOffset) { builder.AddStruct(13, poleVectorOffset.Value, 0); }
  public static void AddTwist(FlatBufferBuilder builder, float twist) { builder.AddFloat(14, twist, 0.0f); }
  public static void AddWeight(FlatBufferBuilder builder, float weight) { builder.AddFloat(15, weight, 0.0f); }
  public static void AddToeSolverData(FlatBufferBuilder builder, Offset<gfl.anm2.fb.ToeSolverData> toeSolverDataOffset) { builder.AddOffset(16, toeSolverDataOffset.Value, 0); }
  public static void AddTargetOffsetIsEnabled(FlatBufferBuilder builder, bool targetOffsetIsEnabled) { builder.AddBool(17, targetOffsetIsEnabled, false); }
  public static Offset<gfl.anm2.fb.TwoBoneIKSetData> EndTwoBoneIKSetData(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fb.TwoBoneIKSetData>(o);
  }
  public TwoBoneIKSetDataT UnPack() {
    var _o = new TwoBoneIKSetDataT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(TwoBoneIKSetDataT _o) {
    _o.IsEnabled = this.IsEnabled;
    _o.RootNodeName = this.RootNodeName;
    _o.MiddleNodeName = this.MiddleNodeName;
    _o.TipNodeName = this.TipNodeName;
    _o.RootConstraintIsEnabled = this.RootConstraintIsEnabled;
    _o.RootConstraintRangeAxisYPositive = this.RootConstraintRangeAxisYPositive;
    _o.RootConstraintRangeAxisYNegative = this.RootConstraintRangeAxisYNegative;
    _o.RootConstraintRangeAxisZPositive = this.RootConstraintRangeAxisZPositive;
    _o.RootConstraintRangeAxisZNegative = this.RootConstraintRangeAxisZNegative;
    _o.RootConstraintIterations = this.RootConstraintIterations;
    _o.MiddleConstraintIsEnabled = this.MiddleConstraintIsEnabled;
    _o.MiddleConstraintRangePositive = this.MiddleConstraintRangePositive;
    _o.MiddleConstraintRangeNegative = this.MiddleConstraintRangeNegative;
    _o.PoleVector = this.PoleVector.HasValue ? this.PoleVector.Value.UnPack() : null;
    _o.Twist = this.Twist;
    _o.Weight = this.Weight;
    _o.ToeSolverData = this.ToeSolverData.HasValue ? this.ToeSolverData.Value.UnPack() : null;
    _o.TargetOffsetIsEnabled = this.TargetOffsetIsEnabled;
  }
  public static Offset<gfl.anm2.fb.TwoBoneIKSetData> Pack(FlatBufferBuilder builder, TwoBoneIKSetDataT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fb.TwoBoneIKSetData>);
    var _rootNodeName = _o.RootNodeName == null ? default(StringOffset) : builder.CreateString(_o.RootNodeName);
    var _middleNodeName = _o.MiddleNodeName == null ? default(StringOffset) : builder.CreateString(_o.MiddleNodeName);
    var _tipNodeName = _o.TipNodeName == null ? default(StringOffset) : builder.CreateString(_o.TipNodeName);
    var _toeSolverData = _o.ToeSolverData == null ? default(Offset<gfl.anm2.fb.ToeSolverData>) : gfl.anm2.fb.ToeSolverData.Pack(builder, _o.ToeSolverData);
    return CreateTwoBoneIKSetData(
      builder,
      _o.IsEnabled,
      _rootNodeName,
      _middleNodeName,
      _tipNodeName,
      _o.RootConstraintIsEnabled,
      _o.RootConstraintRangeAxisYPositive,
      _o.RootConstraintRangeAxisYNegative,
      _o.RootConstraintRangeAxisZPositive,
      _o.RootConstraintRangeAxisZNegative,
      _o.RootConstraintIterations,
      _o.MiddleConstraintIsEnabled,
      _o.MiddleConstraintRangePositive,
      _o.MiddleConstraintRangeNegative,
      _o.PoleVector,
      _o.Twist,
      _o.Weight,
      _toeSolverData,
      _o.TargetOffsetIsEnabled);
  }
};

public class TwoBoneIKSetDataT
{
  [Newtonsoft.Json.JsonProperty("isEnabled")]
  public bool IsEnabled { get; set; }
  [Newtonsoft.Json.JsonProperty("rootNodeName")]
  public string RootNodeName { get; set; }
  [Newtonsoft.Json.JsonProperty("middleNodeName")]
  public string MiddleNodeName { get; set; }
  [Newtonsoft.Json.JsonProperty("tipNodeName")]
  public string TipNodeName { get; set; }
  [Newtonsoft.Json.JsonProperty("rootConstraintIsEnabled")]
  public bool RootConstraintIsEnabled { get; set; }
  [Newtonsoft.Json.JsonProperty("rootConstraintRangeAxisY_Positive")]
  public float RootConstraintRangeAxisYPositive { get; set; }
  [Newtonsoft.Json.JsonProperty("rootConstraintRangeAxisY_Negative")]
  public float RootConstraintRangeAxisYNegative { get; set; }
  [Newtonsoft.Json.JsonProperty("rootConstraintRangeAxisZ_Positive")]
  public float RootConstraintRangeAxisZPositive { get; set; }
  [Newtonsoft.Json.JsonProperty("rootConstraintRangeAxisZ_Negative")]
  public float RootConstraintRangeAxisZNegative { get; set; }
  [Newtonsoft.Json.JsonProperty("rootConstraintIterations")]
  public int RootConstraintIterations { get; set; }
  [Newtonsoft.Json.JsonProperty("middleConstraintIsEnabled")]
  public bool MiddleConstraintIsEnabled { get; set; }
  [Newtonsoft.Json.JsonProperty("middleConstraintRange_Positive")]
  public float MiddleConstraintRangePositive { get; set; }
  [Newtonsoft.Json.JsonProperty("middleConstraintRange_Negative")]
  public float MiddleConstraintRangeNegative { get; set; }
  [Newtonsoft.Json.JsonProperty("poleVector")]
  public gfl.anm2.fb.VectorT PoleVector { get; set; }
  [Newtonsoft.Json.JsonProperty("twist")]
  public float Twist { get; set; }
  [Newtonsoft.Json.JsonProperty("weight")]
  public float Weight { get; set; }
  [Newtonsoft.Json.JsonProperty("toeSolverData")]
  public gfl.anm2.fb.ToeSolverDataT ToeSolverData { get; set; }
  [Newtonsoft.Json.JsonProperty("targetOffsetIsEnabled")]
  public bool TargetOffsetIsEnabled { get; set; }

  public TwoBoneIKSetDataT() {
    this.IsEnabled = false;
    this.RootNodeName = null;
    this.MiddleNodeName = null;
    this.TipNodeName = null;
    this.RootConstraintIsEnabled = false;
    this.RootConstraintRangeAxisYPositive = 0.0f;
    this.RootConstraintRangeAxisYNegative = 0.0f;
    this.RootConstraintRangeAxisZPositive = 0.0f;
    this.RootConstraintRangeAxisZNegative = 0.0f;
    this.RootConstraintIterations = 0;
    this.MiddleConstraintIsEnabled = false;
    this.MiddleConstraintRangePositive = 0.0f;
    this.MiddleConstraintRangeNegative = 0.0f;
    this.PoleVector = new gfl.anm2.fb.VectorT();
    this.Twist = 0.0f;
    this.Weight = 0.0f;
    this.ToeSolverData = null;
    this.TargetOffsetIsEnabled = false;
  }
}

public struct MultiJointIKData : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static MultiJointIKData GetRootAsMultiJointIKData(ByteBuffer _bb) { return GetRootAsMultiJointIKData(_bb, new MultiJointIKData()); }
  public static MultiJointIKData GetRootAsMultiJointIKData(ByteBuffer _bb, MultiJointIKData obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public MultiJointIKData __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public bool IsEnabled { get { int o = __p.__offset(4); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public float Factor { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)1.0f; } }
  public string StartJointName { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetStartJointNameBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetStartJointNameBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetStartJointNameArray() { return __p.__vector_as_array<byte>(8); }
  public string EndJointName { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetEndJointNameBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetEndJointNameBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetEndJointNameArray() { return __p.__vector_as_array<byte>(10); }
  public float Precision { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.001f; } }
  public int Iterations { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)5; } }

  public static Offset<gfl.anm2.fb.MultiJointIKData> CreateMultiJointIKData(FlatBufferBuilder builder,
      bool isEnabled = false,
      float factor = 1.0f,
      StringOffset startJointNameOffset = default(StringOffset),
      StringOffset endJointNameOffset = default(StringOffset),
      float precision = 0.001f,
      int iterations = 5) {
    builder.StartTable(6);
    MultiJointIKData.AddIterations(builder, iterations);
    MultiJointIKData.AddPrecision(builder, precision);
    MultiJointIKData.AddEndJointName(builder, endJointNameOffset);
    MultiJointIKData.AddStartJointName(builder, startJointNameOffset);
    MultiJointIKData.AddFactor(builder, factor);
    MultiJointIKData.AddIsEnabled(builder, isEnabled);
    return MultiJointIKData.EndMultiJointIKData(builder);
  }

  public static void StartMultiJointIKData(FlatBufferBuilder builder) { builder.StartTable(6); }
  public static void AddIsEnabled(FlatBufferBuilder builder, bool isEnabled) { builder.AddBool(0, isEnabled, false); }
  public static void AddFactor(FlatBufferBuilder builder, float factor) { builder.AddFloat(1, factor, 1.0f); }
  public static void AddStartJointName(FlatBufferBuilder builder, StringOffset startJointNameOffset) { builder.AddOffset(2, startJointNameOffset.Value, 0); }
  public static void AddEndJointName(FlatBufferBuilder builder, StringOffset endJointNameOffset) { builder.AddOffset(3, endJointNameOffset.Value, 0); }
  public static void AddPrecision(FlatBufferBuilder builder, float precision) { builder.AddFloat(4, precision, 0.001f); }
  public static void AddIterations(FlatBufferBuilder builder, int iterations) { builder.AddInt(5, iterations, 5); }
  public static Offset<gfl.anm2.fb.MultiJointIKData> EndMultiJointIKData(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fb.MultiJointIKData>(o);
  }
  public MultiJointIKDataT UnPack() {
    var _o = new MultiJointIKDataT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(MultiJointIKDataT _o) {
    _o.IsEnabled = this.IsEnabled;
    _o.Factor = this.Factor;
    _o.StartJointName = this.StartJointName;
    _o.EndJointName = this.EndJointName;
    _o.Precision = this.Precision;
    _o.Iterations = this.Iterations;
  }
  public static Offset<gfl.anm2.fb.MultiJointIKData> Pack(FlatBufferBuilder builder, MultiJointIKDataT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fb.MultiJointIKData>);
    var _startJointName = _o.StartJointName == null ? default(StringOffset) : builder.CreateString(_o.StartJointName);
    var _endJointName = _o.EndJointName == null ? default(StringOffset) : builder.CreateString(_o.EndJointName);
    return CreateMultiJointIKData(
      builder,
      _o.IsEnabled,
      _o.Factor,
      _startJointName,
      _endJointName,
      _o.Precision,
      _o.Iterations);
  }
};

public class MultiJointIKDataT
{
  [Newtonsoft.Json.JsonProperty("isEnabled")]
  public bool IsEnabled { get; set; }
  [Newtonsoft.Json.JsonProperty("factor")]
  public float Factor { get; set; }
  [Newtonsoft.Json.JsonProperty("startJointName")]
  public string StartJointName { get; set; }
  [Newtonsoft.Json.JsonProperty("endJointName")]
  public string EndJointName { get; set; }
  [Newtonsoft.Json.JsonProperty("precision")]
  public float Precision { get; set; }
  [Newtonsoft.Json.JsonProperty("iterations")]
  public int Iterations { get; set; }

  public MultiJointIKDataT() {
    this.IsEnabled = false;
    this.Factor = 1.0f;
    this.StartJointName = null;
    this.EndJointName = null;
    this.Precision = 0.001f;
    this.Iterations = 5;
  }
}

public struct TwoBoneIKGroupData : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static TwoBoneIKGroupData GetRootAsTwoBoneIKGroupData(ByteBuffer _bb) { return GetRootAsTwoBoneIKGroupData(_bb, new TwoBoneIKGroupData()); }
  public static TwoBoneIKGroupData GetRootAsTwoBoneIKGroupData(ByteBuffer _bb, TwoBoneIKGroupData obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public TwoBoneIKGroupData __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string GroupName { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetGroupNameBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetGroupNameBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetGroupNameArray() { return __p.__vector_as_array<byte>(4); }
  public gfl.anm2.fb.TwoBoneIKSetData? TwoBoneIKSet { get { int o = __p.__offset(6); return o != 0 ? (gfl.anm2.fb.TwoBoneIKSetData?)(new gfl.anm2.fb.TwoBoneIKSetData()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public gfl.anm2.fb.MultiJointIKData? MultiJointIKData { get { int o = __p.__offset(8); return o != 0 ? (gfl.anm2.fb.MultiJointIKData?)(new gfl.anm2.fb.MultiJointIKData()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }

  public static Offset<gfl.anm2.fb.TwoBoneIKGroupData> CreateTwoBoneIKGroupData(FlatBufferBuilder builder,
      StringOffset groupNameOffset = default(StringOffset),
      Offset<gfl.anm2.fb.TwoBoneIKSetData> twoBoneIKSetOffset = default(Offset<gfl.anm2.fb.TwoBoneIKSetData>),
      Offset<gfl.anm2.fb.MultiJointIKData> multiJointIKDataOffset = default(Offset<gfl.anm2.fb.MultiJointIKData>)) {
    builder.StartTable(3);
    TwoBoneIKGroupData.AddMultiJointIKData(builder, multiJointIKDataOffset);
    TwoBoneIKGroupData.AddTwoBoneIKSet(builder, twoBoneIKSetOffset);
    TwoBoneIKGroupData.AddGroupName(builder, groupNameOffset);
    return TwoBoneIKGroupData.EndTwoBoneIKGroupData(builder);
  }

  public static void StartTwoBoneIKGroupData(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddGroupName(FlatBufferBuilder builder, StringOffset groupNameOffset) { builder.AddOffset(0, groupNameOffset.Value, 0); }
  public static void AddTwoBoneIKSet(FlatBufferBuilder builder, Offset<gfl.anm2.fb.TwoBoneIKSetData> twoBoneIKSetOffset) { builder.AddOffset(1, twoBoneIKSetOffset.Value, 0); }
  public static void AddMultiJointIKData(FlatBufferBuilder builder, Offset<gfl.anm2.fb.MultiJointIKData> multiJointIKDataOffset) { builder.AddOffset(2, multiJointIKDataOffset.Value, 0); }
  public static Offset<gfl.anm2.fb.TwoBoneIKGroupData> EndTwoBoneIKGroupData(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fb.TwoBoneIKGroupData>(o);
  }
  public TwoBoneIKGroupDataT UnPack() {
    var _o = new TwoBoneIKGroupDataT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(TwoBoneIKGroupDataT _o) {
    _o.GroupName = this.GroupName;
    _o.TwoBoneIKSet = this.TwoBoneIKSet.HasValue ? this.TwoBoneIKSet.Value.UnPack() : null;
    _o.MultiJointIKData = this.MultiJointIKData.HasValue ? this.MultiJointIKData.Value.UnPack() : null;
  }
  public static Offset<gfl.anm2.fb.TwoBoneIKGroupData> Pack(FlatBufferBuilder builder, TwoBoneIKGroupDataT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fb.TwoBoneIKGroupData>);
    var _groupName = _o.GroupName == null ? default(StringOffset) : builder.CreateString(_o.GroupName);
    var _twoBoneIKSet = _o.TwoBoneIKSet == null ? default(Offset<gfl.anm2.fb.TwoBoneIKSetData>) : gfl.anm2.fb.TwoBoneIKSetData.Pack(builder, _o.TwoBoneIKSet);
    var _multiJointIKData = _o.MultiJointIKData == null ? default(Offset<gfl.anm2.fb.MultiJointIKData>) : gfl.anm2.fb.MultiJointIKData.Pack(builder, _o.MultiJointIKData);
    return CreateTwoBoneIKGroupData(
      builder,
      _groupName,
      _twoBoneIKSet,
      _multiJointIKData);
  }
};

public class TwoBoneIKGroupDataT
{
  [Newtonsoft.Json.JsonProperty("groupName")]
  public string GroupName { get; set; }
  [Newtonsoft.Json.JsonProperty("twoBoneIKSet")]
  public gfl.anm2.fb.TwoBoneIKSetDataT TwoBoneIKSet { get; set; }
  [Newtonsoft.Json.JsonProperty("multiJointIKData")]
  public gfl.anm2.fb.MultiJointIKDataT MultiJointIKData { get; set; }

  public TwoBoneIKGroupDataT() {
    this.GroupName = null;
    this.TwoBoneIKSet = null;
    this.MultiJointIKData = null;
  }
}

public struct OriginOrientationSolverData : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static OriginOrientationSolverData GetRootAsOriginOrientationSolverData(ByteBuffer _bb) { return GetRootAsOriginOrientationSolverData(_bb, new OriginOrientationSolverData()); }
  public static OriginOrientationSolverData GetRootAsOriginOrientationSolverData(ByteBuffer _bb, OriginOrientationSolverData obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public OriginOrientationSolverData __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public bool IsEnabled { get { int o = __p.__offset(4); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public float Factor { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<gfl.anm2.fb.OriginOrientationSolverData> CreateOriginOrientationSolverData(FlatBufferBuilder builder,
      bool isEnabled = false,
      float factor = 0.0f) {
    builder.StartTable(2);
    OriginOrientationSolverData.AddFactor(builder, factor);
    OriginOrientationSolverData.AddIsEnabled(builder, isEnabled);
    return OriginOrientationSolverData.EndOriginOrientationSolverData(builder);
  }

  public static void StartOriginOrientationSolverData(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddIsEnabled(FlatBufferBuilder builder, bool isEnabled) { builder.AddBool(0, isEnabled, false); }
  public static void AddFactor(FlatBufferBuilder builder, float factor) { builder.AddFloat(1, factor, 0.0f); }
  public static Offset<gfl.anm2.fb.OriginOrientationSolverData> EndOriginOrientationSolverData(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fb.OriginOrientationSolverData>(o);
  }
  public OriginOrientationSolverDataT UnPack() {
    var _o = new OriginOrientationSolverDataT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(OriginOrientationSolverDataT _o) {
    _o.IsEnabled = this.IsEnabled;
    _o.Factor = this.Factor;
  }
  public static Offset<gfl.anm2.fb.OriginOrientationSolverData> Pack(FlatBufferBuilder builder, OriginOrientationSolverDataT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fb.OriginOrientationSolverData>);
    return CreateOriginOrientationSolverData(
      builder,
      _o.IsEnabled,
      _o.Factor);
  }
};

public class OriginOrientationSolverDataT
{
  [Newtonsoft.Json.JsonProperty("isEnabled")]
  public bool IsEnabled { get; set; }
  [Newtonsoft.Json.JsonProperty("factor")]
  public float Factor { get; set; }

  public OriginOrientationSolverDataT() {
    this.IsEnabled = false;
    this.Factor = 0.0f;
  }
}

public struct WaistOffsetSolverData : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static WaistOffsetSolverData GetRootAsWaistOffsetSolverData(ByteBuffer _bb) { return GetRootAsWaistOffsetSolverData(_bb, new WaistOffsetSolverData()); }
  public static WaistOffsetSolverData GetRootAsWaistOffsetSolverData(ByteBuffer _bb, WaistOffsetSolverData obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public WaistOffsetSolverData __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public bool IsEnabled { get { int o = __p.__offset(4); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public float Factor { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public bool LimitFootHeightIsEnabled { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public float LimitFootHeightDifference { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.25f; } }

  public static Offset<gfl.anm2.fb.WaistOffsetSolverData> CreateWaistOffsetSolverData(FlatBufferBuilder builder,
      bool isEnabled = false,
      float factor = 0.0f,
      bool limitFootHeightIsEnabled = false,
      float limitFootHeightDifference = 0.25f) {
    builder.StartTable(4);
    WaistOffsetSolverData.AddLimitFootHeightDifference(builder, limitFootHeightDifference);
    WaistOffsetSolverData.AddFactor(builder, factor);
    WaistOffsetSolverData.AddLimitFootHeightIsEnabled(builder, limitFootHeightIsEnabled);
    WaistOffsetSolverData.AddIsEnabled(builder, isEnabled);
    return WaistOffsetSolverData.EndWaistOffsetSolverData(builder);
  }

  public static void StartWaistOffsetSolverData(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddIsEnabled(FlatBufferBuilder builder, bool isEnabled) { builder.AddBool(0, isEnabled, false); }
  public static void AddFactor(FlatBufferBuilder builder, float factor) { builder.AddFloat(1, factor, 0.0f); }
  public static void AddLimitFootHeightIsEnabled(FlatBufferBuilder builder, bool limitFootHeightIsEnabled) { builder.AddBool(2, limitFootHeightIsEnabled, false); }
  public static void AddLimitFootHeightDifference(FlatBufferBuilder builder, float limitFootHeightDifference) { builder.AddFloat(3, limitFootHeightDifference, 0.25f); }
  public static Offset<gfl.anm2.fb.WaistOffsetSolverData> EndWaistOffsetSolverData(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fb.WaistOffsetSolverData>(o);
  }
  public WaistOffsetSolverDataT UnPack() {
    var _o = new WaistOffsetSolverDataT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(WaistOffsetSolverDataT _o) {
    _o.IsEnabled = this.IsEnabled;
    _o.Factor = this.Factor;
    _o.LimitFootHeightIsEnabled = this.LimitFootHeightIsEnabled;
    _o.LimitFootHeightDifference = this.LimitFootHeightDifference;
  }
  public static Offset<gfl.anm2.fb.WaistOffsetSolverData> Pack(FlatBufferBuilder builder, WaistOffsetSolverDataT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fb.WaistOffsetSolverData>);
    return CreateWaistOffsetSolverData(
      builder,
      _o.IsEnabled,
      _o.Factor,
      _o.LimitFootHeightIsEnabled,
      _o.LimitFootHeightDifference);
  }
};

public class WaistOffsetSolverDataT
{
  [Newtonsoft.Json.JsonProperty("isEnabled")]
  public bool IsEnabled { get; set; }
  [Newtonsoft.Json.JsonProperty("factor")]
  public float Factor { get; set; }
  [Newtonsoft.Json.JsonProperty("limitFootHeightIsEnabled")]
  public bool LimitFootHeightIsEnabled { get; set; }
  [Newtonsoft.Json.JsonProperty("limitFootHeightDifference")]
  public float LimitFootHeightDifference { get; set; }

  public WaistOffsetSolverDataT() {
    this.IsEnabled = false;
    this.Factor = 0.0f;
    this.LimitFootHeightIsEnabled = false;
    this.LimitFootHeightDifference = 0.25f;
  }
}

public struct TwoBoneIKData : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static TwoBoneIKData GetRootAsTwoBoneIKData(ByteBuffer _bb) { return GetRootAsTwoBoneIKData(_bb, new TwoBoneIKData()); }
  public static TwoBoneIKData GetRootAsTwoBoneIKData(ByteBuffer _bb, TwoBoneIKData obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public TwoBoneIKData __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public gfl.anm2.fb.TwoBoneIKGroupData? TwoBoneIKGroups(int j) { int o = __p.__offset(4); return o != 0 ? (gfl.anm2.fb.TwoBoneIKGroupData?)(new gfl.anm2.fb.TwoBoneIKGroupData()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int TwoBoneIKGroupsLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
  public bool IsUseAdditionalParameterWeights { get { int o = __p.__offset(6); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public gfl.anm2.fb.OriginOrientationSolverData? OriginOrientationSolverData { get { int o = __p.__offset(8); return o != 0 ? (gfl.anm2.fb.OriginOrientationSolverData?)(new gfl.anm2.fb.OriginOrientationSolverData()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public gfl.anm2.fb.WaistOffsetSolverData? WaistOffsetSolverData { get { int o = __p.__offset(10); return o != 0 ? (gfl.anm2.fb.WaistOffsetSolverData?)(new gfl.anm2.fb.WaistOffsetSolverData()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public float Factor { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<gfl.anm2.fb.TwoBoneIKData> CreateTwoBoneIKData(FlatBufferBuilder builder,
      VectorOffset twoBoneIKGroupsOffset = default(VectorOffset),
      bool isUseAdditionalParameterWeights = false,
      Offset<gfl.anm2.fb.OriginOrientationSolverData> originOrientationSolverDataOffset = default(Offset<gfl.anm2.fb.OriginOrientationSolverData>),
      Offset<gfl.anm2.fb.WaistOffsetSolverData> waistOffsetSolverDataOffset = default(Offset<gfl.anm2.fb.WaistOffsetSolverData>),
      float factor = 0.0f) {
    builder.StartTable(5);
    TwoBoneIKData.AddFactor(builder, factor);
    TwoBoneIKData.AddWaistOffsetSolverData(builder, waistOffsetSolverDataOffset);
    TwoBoneIKData.AddOriginOrientationSolverData(builder, originOrientationSolverDataOffset);
    TwoBoneIKData.AddTwoBoneIKGroups(builder, twoBoneIKGroupsOffset);
    TwoBoneIKData.AddIsUseAdditionalParameterWeights(builder, isUseAdditionalParameterWeights);
    return TwoBoneIKData.EndTwoBoneIKData(builder);
  }

  public static void StartTwoBoneIKData(FlatBufferBuilder builder) { builder.StartTable(5); }
  public static void AddTwoBoneIKGroups(FlatBufferBuilder builder, VectorOffset twoBoneIKGroupsOffset) { builder.AddOffset(0, twoBoneIKGroupsOffset.Value, 0); }
  public static VectorOffset CreateTwoBoneIKGroupsVector(FlatBufferBuilder builder, Offset<gfl.anm2.fb.TwoBoneIKGroupData>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateTwoBoneIKGroupsVectorBlock(FlatBufferBuilder builder, Offset<gfl.anm2.fb.TwoBoneIKGroupData>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartTwoBoneIKGroupsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddIsUseAdditionalParameterWeights(FlatBufferBuilder builder, bool isUseAdditionalParameterWeights) { builder.AddBool(1, isUseAdditionalParameterWeights, false); }
  public static void AddOriginOrientationSolverData(FlatBufferBuilder builder, Offset<gfl.anm2.fb.OriginOrientationSolverData> originOrientationSolverDataOffset) { builder.AddOffset(2, originOrientationSolverDataOffset.Value, 0); }
  public static void AddWaistOffsetSolverData(FlatBufferBuilder builder, Offset<gfl.anm2.fb.WaistOffsetSolverData> waistOffsetSolverDataOffset) { builder.AddOffset(3, waistOffsetSolverDataOffset.Value, 0); }
  public static void AddFactor(FlatBufferBuilder builder, float factor) { builder.AddFloat(4, factor, 0.0f); }
  public static Offset<gfl.anm2.fb.TwoBoneIKData> EndTwoBoneIKData(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.anm2.fb.TwoBoneIKData>(o);
  }
  public static void FinishTwoBoneIKDataBuffer(FlatBufferBuilder builder, Offset<gfl.anm2.fb.TwoBoneIKData> offset) { builder.Finish(offset.Value); }
  public static void FinishSizePrefixedTwoBoneIKDataBuffer(FlatBufferBuilder builder, Offset<gfl.anm2.fb.TwoBoneIKData> offset) { builder.FinishSizePrefixed(offset.Value); }
  public TwoBoneIKDataT UnPack() {
    var _o = new TwoBoneIKDataT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(TwoBoneIKDataT _o) {
    _o.TwoBoneIKGroups = new List<gfl.anm2.fb.TwoBoneIKGroupDataT>();
    for (var _j = 0; _j < this.TwoBoneIKGroupsLength; ++_j) {_o.TwoBoneIKGroups.Add(this.TwoBoneIKGroups(_j).HasValue ? this.TwoBoneIKGroups(_j).Value.UnPack() : null);}
    _o.IsUseAdditionalParameterWeights = this.IsUseAdditionalParameterWeights;
    _o.OriginOrientationSolverData = this.OriginOrientationSolverData.HasValue ? this.OriginOrientationSolverData.Value.UnPack() : null;
    _o.WaistOffsetSolverData = this.WaistOffsetSolverData.HasValue ? this.WaistOffsetSolverData.Value.UnPack() : null;
    _o.Factor = this.Factor;
  }
  public static Offset<gfl.anm2.fb.TwoBoneIKData> Pack(FlatBufferBuilder builder, TwoBoneIKDataT _o) {
    if (_o == null) return default(Offset<gfl.anm2.fb.TwoBoneIKData>);
    var _twoBoneIKGroups = default(VectorOffset);
    if (_o.TwoBoneIKGroups != null) {
      var __twoBoneIKGroups = new Offset<gfl.anm2.fb.TwoBoneIKGroupData>[_o.TwoBoneIKGroups.Count];
      for (var _j = 0; _j < __twoBoneIKGroups.Length; ++_j) { __twoBoneIKGroups[_j] = gfl.anm2.fb.TwoBoneIKGroupData.Pack(builder, _o.TwoBoneIKGroups[_j]); }
      _twoBoneIKGroups = CreateTwoBoneIKGroupsVector(builder, __twoBoneIKGroups);
    }
    var _originOrientationSolverData = _o.OriginOrientationSolverData == null ? default(Offset<gfl.anm2.fb.OriginOrientationSolverData>) : gfl.anm2.fb.OriginOrientationSolverData.Pack(builder, _o.OriginOrientationSolverData);
    var _waistOffsetSolverData = _o.WaistOffsetSolverData == null ? default(Offset<gfl.anm2.fb.WaistOffsetSolverData>) : gfl.anm2.fb.WaistOffsetSolverData.Pack(builder, _o.WaistOffsetSolverData);
    return CreateTwoBoneIKData(
      builder,
      _twoBoneIKGroups,
      _o.IsUseAdditionalParameterWeights,
      _originOrientationSolverData,
      _waistOffsetSolverData,
      _o.Factor);
  }
};

public class TwoBoneIKDataT
{
  [Newtonsoft.Json.JsonProperty("twoBoneIKGroups")]
  public List<gfl.anm2.fb.TwoBoneIKGroupDataT> TwoBoneIKGroups { get; set; }
  [Newtonsoft.Json.JsonProperty("isUseAdditionalParameterWeights")]
  public bool IsUseAdditionalParameterWeights { get; set; }
  [Newtonsoft.Json.JsonProperty("originOrientationSolverData")]
  public gfl.anm2.fb.OriginOrientationSolverDataT OriginOrientationSolverData { get; set; }
  [Newtonsoft.Json.JsonProperty("waistOffsetSolverData")]
  public gfl.anm2.fb.WaistOffsetSolverDataT WaistOffsetSolverData { get; set; }
  [Newtonsoft.Json.JsonProperty("factor")]
  public float Factor { get; set; }

  public TwoBoneIKDataT() {
    this.TwoBoneIKGroups = null;
    this.IsUseAdditionalParameterWeights = false;
    this.OriginOrientationSolverData = null;
    this.WaistOffsetSolverData = null;
    this.Factor = 0.0f;
  }

  public static TwoBoneIKDataT DeserializeFromJson(string jsonText) {
    return Newtonsoft.Json.JsonConvert.DeserializeObject<TwoBoneIKDataT>(jsonText);
  }
  public string SerializeToJson() {
    return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
  }
  public static TwoBoneIKDataT DeserializeFromBinary(byte[] fbBuffer) {
    return TwoBoneIKData.GetRootAsTwoBoneIKData(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    TwoBoneIKData.FinishTwoBoneIKDataBuffer(fbb, TwoBoneIKData.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


}
