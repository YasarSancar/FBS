// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace AiEditor.Fb
{

using global::System;
using global::System.Collections.Generic;
using global::FlatBuffers;

public struct Vector2 : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static Vector2 GetRootAsVector2(ByteBuffer _bb) { return GetRootAsVector2(_bb, new Vector2()); }
  public static Vector2 GetRootAsVector2(ByteBuffer _bb, Vector2 obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Vector2 __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float X { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float Y { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<AiEditor.Fb.Vector2> CreateVector2(FlatBufferBuilder builder,
      float x = 0.0f,
      float y = 0.0f) {
    builder.StartTable(2);
    Vector2.AddY(builder, y);
    Vector2.AddX(builder, x);
    return Vector2.EndVector2(builder);
  }

  public static void StartVector2(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddX(FlatBufferBuilder builder, float x) { builder.AddFloat(0, x, 0.0f); }
  public static void AddY(FlatBufferBuilder builder, float y) { builder.AddFloat(1, y, 0.0f); }
  public static Offset<AiEditor.Fb.Vector2> EndVector2(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<AiEditor.Fb.Vector2>(o);
  }
  public Vector2T UnPack() {
    var _o = new Vector2T();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(Vector2T _o) {
    _o.X = this.X;
    _o.Y = this.Y;
  }
  public static Offset<AiEditor.Fb.Vector2> Pack(FlatBufferBuilder builder, Vector2T _o) {
    if (_o == null) return default(Offset<AiEditor.Fb.Vector2>);
    return CreateVector2(
      builder,
      _o.X,
      _o.Y);
  }
};

public class Vector2T
{
  [Newtonsoft.Json.JsonProperty("x")]
  public float X { get; set; }
  [Newtonsoft.Json.JsonProperty("y")]
  public float Y { get; set; }

  public Vector2T() {
    this.X = 0.0f;
    this.Y = 0.0f;
  }
}

public struct Vector3 : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static Vector3 GetRootAsVector3(ByteBuffer _bb) { return GetRootAsVector3(_bb, new Vector3()); }
  public static Vector3 GetRootAsVector3(ByteBuffer _bb, Vector3 obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Vector3 __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float X { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float Y { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float Z { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<AiEditor.Fb.Vector3> CreateVector3(FlatBufferBuilder builder,
      float x = 0.0f,
      float y = 0.0f,
      float z = 0.0f) {
    builder.StartTable(3);
    Vector3.AddZ(builder, z);
    Vector3.AddY(builder, y);
    Vector3.AddX(builder, x);
    return Vector3.EndVector3(builder);
  }

  public static void StartVector3(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddX(FlatBufferBuilder builder, float x) { builder.AddFloat(0, x, 0.0f); }
  public static void AddY(FlatBufferBuilder builder, float y) { builder.AddFloat(1, y, 0.0f); }
  public static void AddZ(FlatBufferBuilder builder, float z) { builder.AddFloat(2, z, 0.0f); }
  public static Offset<AiEditor.Fb.Vector3> EndVector3(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<AiEditor.Fb.Vector3>(o);
  }
  public Vector3T UnPack() {
    var _o = new Vector3T();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(Vector3T _o) {
    _o.X = this.X;
    _o.Y = this.Y;
    _o.Z = this.Z;
  }
  public static Offset<AiEditor.Fb.Vector3> Pack(FlatBufferBuilder builder, Vector3T _o) {
    if (_o == null) return default(Offset<AiEditor.Fb.Vector3>);
    return CreateVector3(
      builder,
      _o.X,
      _o.Y,
      _o.Z);
  }
};

public class Vector3T
{
  [Newtonsoft.Json.JsonProperty("x")]
  public float X { get; set; }
  [Newtonsoft.Json.JsonProperty("y")]
  public float Y { get; set; }
  [Newtonsoft.Json.JsonProperty("z")]
  public float Z { get; set; }

  public Vector3T() {
    this.X = 0.0f;
    this.Y = 0.0f;
    this.Z = 0.0f;
  }
}

public struct FloatingNodes : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static FloatingNodes GetRootAsFloatingNodes(ByteBuffer _bb) { return GetRootAsFloatingNodes(_bb, new FloatingNodes()); }
  public static FloatingNodes GetRootAsFloatingNodes(ByteBuffer _bb, FloatingNodes obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public FloatingNodes __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string ParentNodeId { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetParentNodeIdBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetParentNodeIdBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetParentNodeIdArray() { return __p.__vector_as_array<byte>(4); }
  public common.ai.bt.fb.NodeData? Nodes(int j) { int o = __p.__offset(6); return o != 0 ? (common.ai.bt.fb.NodeData?)(new common.ai.bt.fb.NodeData()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int NodesLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
  public common.ai.bt.fb.Connect? Connects(int j) { int o = __p.__offset(8); return o != 0 ? (common.ai.bt.fb.Connect?)(new common.ai.bt.fb.Connect()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int ConnectsLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<AiEditor.Fb.FloatingNodes> CreateFloatingNodes(FlatBufferBuilder builder,
      StringOffset parentNodeIdOffset = default(StringOffset),
      VectorOffset nodesOffset = default(VectorOffset),
      VectorOffset connectsOffset = default(VectorOffset)) {
    builder.StartTable(3);
    FloatingNodes.AddConnects(builder, connectsOffset);
    FloatingNodes.AddNodes(builder, nodesOffset);
    FloatingNodes.AddParentNodeId(builder, parentNodeIdOffset);
    return FloatingNodes.EndFloatingNodes(builder);
  }

  public static void StartFloatingNodes(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddParentNodeId(FlatBufferBuilder builder, StringOffset parentNodeIdOffset) { builder.AddOffset(0, parentNodeIdOffset.Value, 0); }
  public static void AddNodes(FlatBufferBuilder builder, VectorOffset nodesOffset) { builder.AddOffset(1, nodesOffset.Value, 0); }
  public static VectorOffset CreateNodesVector(FlatBufferBuilder builder, Offset<common.ai.bt.fb.NodeData>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateNodesVectorBlock(FlatBufferBuilder builder, Offset<common.ai.bt.fb.NodeData>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartNodesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddConnects(FlatBufferBuilder builder, VectorOffset connectsOffset) { builder.AddOffset(2, connectsOffset.Value, 0); }
  public static VectorOffset CreateConnectsVector(FlatBufferBuilder builder, Offset<common.ai.bt.fb.Connect>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateConnectsVectorBlock(FlatBufferBuilder builder, Offset<common.ai.bt.fb.Connect>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartConnectsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<AiEditor.Fb.FloatingNodes> EndFloatingNodes(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<AiEditor.Fb.FloatingNodes>(o);
  }
  public FloatingNodesT UnPack() {
    var _o = new FloatingNodesT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(FloatingNodesT _o) {
    _o.ParentNodeId = this.ParentNodeId;
    _o.Nodes = new List<common.ai.bt.fb.NodeDataT>();
    for (var _j = 0; _j < this.NodesLength; ++_j) {_o.Nodes.Add(this.Nodes(_j).HasValue ? this.Nodes(_j).Value.UnPack() : null);}
    _o.Connects = new List<common.ai.bt.fb.ConnectT>();
    for (var _j = 0; _j < this.ConnectsLength; ++_j) {_o.Connects.Add(this.Connects(_j).HasValue ? this.Connects(_j).Value.UnPack() : null);}
  }
  public static Offset<AiEditor.Fb.FloatingNodes> Pack(FlatBufferBuilder builder, FloatingNodesT _o) {
    if (_o == null) return default(Offset<AiEditor.Fb.FloatingNodes>);
    var _parentNodeId = _o.ParentNodeId == null ? default(StringOffset) : builder.CreateString(_o.ParentNodeId);
    var _nodes = default(VectorOffset);
    if (_o.Nodes != null) {
      var __nodes = new Offset<common.ai.bt.fb.NodeData>[_o.Nodes.Count];
      for (var _j = 0; _j < __nodes.Length; ++_j) { __nodes[_j] = common.ai.bt.fb.NodeData.Pack(builder, _o.Nodes[_j]); }
      _nodes = CreateNodesVector(builder, __nodes);
    }
    var _connects = default(VectorOffset);
    if (_o.Connects != null) {
      var __connects = new Offset<common.ai.bt.fb.Connect>[_o.Connects.Count];
      for (var _j = 0; _j < __connects.Length; ++_j) { __connects[_j] = common.ai.bt.fb.Connect.Pack(builder, _o.Connects[_j]); }
      _connects = CreateConnectsVector(builder, __connects);
    }
    return CreateFloatingNodes(
      builder,
      _parentNodeId,
      _nodes,
      _connects);
  }
};

public class FloatingNodesT
{
  [Newtonsoft.Json.JsonProperty("parentNodeId")]
  public string ParentNodeId { get; set; }
  [Newtonsoft.Json.JsonProperty("nodes")]
  public List<common.ai.bt.fb.NodeDataT> Nodes { get; set; }
  [Newtonsoft.Json.JsonProperty("connects")]
  public List<common.ai.bt.fb.ConnectT> Connects { get; set; }

  public FloatingNodesT() {
    this.ParentNodeId = null;
    this.Nodes = null;
    this.Connects = null;
  }
}

public struct NodeMeta : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static NodeMeta GetRootAsNodeMeta(ByteBuffer _bb) { return GetRootAsNodeMeta(_bb, new NodeMeta()); }
  public static NodeMeta GetRootAsNodeMeta(ByteBuffer _bb, NodeMeta obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public NodeMeta __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Id { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetIdBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetIdBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetIdArray() { return __p.__vector_as_array<byte>(4); }
  public AiEditor.Fb.Vector2? Position { get { int o = __p.__offset(6); return o != 0 ? (AiEditor.Fb.Vector2?)(new AiEditor.Fb.Vector2()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public bool IsEnable { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<AiEditor.Fb.NodeMeta> CreateNodeMeta(FlatBufferBuilder builder,
      StringOffset idOffset = default(StringOffset),
      Offset<AiEditor.Fb.Vector2> positionOffset = default(Offset<AiEditor.Fb.Vector2>),
      bool isEnable = false) {
    builder.StartTable(3);
    NodeMeta.AddPosition(builder, positionOffset);
    NodeMeta.AddId(builder, idOffset);
    NodeMeta.AddIsEnable(builder, isEnable);
    return NodeMeta.EndNodeMeta(builder);
  }

  public static void StartNodeMeta(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddId(FlatBufferBuilder builder, StringOffset idOffset) { builder.AddOffset(0, idOffset.Value, 0); }
  public static void AddPosition(FlatBufferBuilder builder, Offset<AiEditor.Fb.Vector2> positionOffset) { builder.AddOffset(1, positionOffset.Value, 0); }
  public static void AddIsEnable(FlatBufferBuilder builder, bool isEnable) { builder.AddBool(2, isEnable, false); }
  public static Offset<AiEditor.Fb.NodeMeta> EndNodeMeta(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<AiEditor.Fb.NodeMeta>(o);
  }
  public NodeMetaT UnPack() {
    var _o = new NodeMetaT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(NodeMetaT _o) {
    _o.Id = this.Id;
    _o.Position = this.Position.HasValue ? this.Position.Value.UnPack() : null;
    _o.IsEnable = this.IsEnable;
  }
  public static Offset<AiEditor.Fb.NodeMeta> Pack(FlatBufferBuilder builder, NodeMetaT _o) {
    if (_o == null) return default(Offset<AiEditor.Fb.NodeMeta>);
    var _id = _o.Id == null ? default(StringOffset) : builder.CreateString(_o.Id);
    var _position = _o.Position == null ? default(Offset<AiEditor.Fb.Vector2>) : AiEditor.Fb.Vector2.Pack(builder, _o.Position);
    return CreateNodeMeta(
      builder,
      _id,
      _position,
      _o.IsEnable);
  }
};

public class NodeMetaT
{
  [Newtonsoft.Json.JsonProperty("id")]
  public string Id { get; set; }
  [Newtonsoft.Json.JsonProperty("position")]
  public AiEditor.Fb.Vector2T Position { get; set; }
  [Newtonsoft.Json.JsonProperty("isEnable")]
  public bool IsEnable { get; set; }

  public NodeMetaT() {
    this.Id = null;
    this.Position = null;
    this.IsEnable = false;
  }
}

public struct BgMeta : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static BgMeta GetRootAsBgMeta(ByteBuffer _bb) { return GetRootAsBgMeta(_bb, new BgMeta()); }
  public static BgMeta GetRootAsBgMeta(ByteBuffer _bb, BgMeta obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BgMeta __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public AiEditor.Fb.Vector2? Translate { get { int o = __p.__offset(4); return o != 0 ? (AiEditor.Fb.Vector2?)(new AiEditor.Fb.Vector2()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public float Scale { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public bool IsViewNodeName { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<AiEditor.Fb.BgMeta> CreateBgMeta(FlatBufferBuilder builder,
      Offset<AiEditor.Fb.Vector2> translateOffset = default(Offset<AiEditor.Fb.Vector2>),
      float scale = 0.0f,
      bool isViewNodeName = false) {
    builder.StartTable(3);
    BgMeta.AddScale(builder, scale);
    BgMeta.AddTranslate(builder, translateOffset);
    BgMeta.AddIsViewNodeName(builder, isViewNodeName);
    return BgMeta.EndBgMeta(builder);
  }

  public static void StartBgMeta(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddTranslate(FlatBufferBuilder builder, Offset<AiEditor.Fb.Vector2> translateOffset) { builder.AddOffset(0, translateOffset.Value, 0); }
  public static void AddScale(FlatBufferBuilder builder, float scale) { builder.AddFloat(1, scale, 0.0f); }
  public static void AddIsViewNodeName(FlatBufferBuilder builder, bool isViewNodeName) { builder.AddBool(2, isViewNodeName, false); }
  public static Offset<AiEditor.Fb.BgMeta> EndBgMeta(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<AiEditor.Fb.BgMeta>(o);
  }
  public BgMetaT UnPack() {
    var _o = new BgMetaT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(BgMetaT _o) {
    _o.Translate = this.Translate.HasValue ? this.Translate.Value.UnPack() : null;
    _o.Scale = this.Scale;
    _o.IsViewNodeName = this.IsViewNodeName;
  }
  public static Offset<AiEditor.Fb.BgMeta> Pack(FlatBufferBuilder builder, BgMetaT _o) {
    if (_o == null) return default(Offset<AiEditor.Fb.BgMeta>);
    var _translate = _o.Translate == null ? default(Offset<AiEditor.Fb.Vector2>) : AiEditor.Fb.Vector2.Pack(builder, _o.Translate);
    return CreateBgMeta(
      builder,
      _translate,
      _o.Scale,
      _o.IsViewNodeName);
  }
};

public class BgMetaT
{
  [Newtonsoft.Json.JsonProperty("translate")]
  public AiEditor.Fb.Vector2T Translate { get; set; }
  [Newtonsoft.Json.JsonProperty("scale")]
  public float Scale { get; set; }
  [Newtonsoft.Json.JsonProperty("isViewNodeName")]
  public bool IsViewNodeName { get; set; }

  public BgMetaT() {
    this.Translate = null;
    this.Scale = 0.0f;
    this.IsViewNodeName = false;
  }
}

public struct RectComment : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static RectComment GetRootAsRectComment(ByteBuffer _bb) { return GetRootAsRectComment(_bb, new RectComment()); }
  public static RectComment GetRootAsRectComment(ByteBuffer _bb, RectComment obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RectComment __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public AiEditor.Fb.Vector2? Min { get { int o = __p.__offset(4); return o != 0 ? (AiEditor.Fb.Vector2?)(new AiEditor.Fb.Vector2()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public AiEditor.Fb.Vector2? Max { get { int o = __p.__offset(6); return o != 0 ? (AiEditor.Fb.Vector2?)(new AiEditor.Fb.Vector2()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public AiEditor.Fb.Vector3? Color { get { int o = __p.__offset(8); return o != 0 ? (AiEditor.Fb.Vector3?)(new AiEditor.Fb.Vector3()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public string Comment { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCommentBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetCommentBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetCommentArray() { return __p.__vector_as_array<byte>(10); }
  public bool IsLinkNode { get { int o = __p.__offset(12); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<AiEditor.Fb.RectComment> CreateRectComment(FlatBufferBuilder builder,
      Offset<AiEditor.Fb.Vector2> minOffset = default(Offset<AiEditor.Fb.Vector2>),
      Offset<AiEditor.Fb.Vector2> maxOffset = default(Offset<AiEditor.Fb.Vector2>),
      Offset<AiEditor.Fb.Vector3> colorOffset = default(Offset<AiEditor.Fb.Vector3>),
      StringOffset commentOffset = default(StringOffset),
      bool isLinkNode = false) {
    builder.StartTable(5);
    RectComment.AddComment(builder, commentOffset);
    RectComment.AddColor(builder, colorOffset);
    RectComment.AddMax(builder, maxOffset);
    RectComment.AddMin(builder, minOffset);
    RectComment.AddIsLinkNode(builder, isLinkNode);
    return RectComment.EndRectComment(builder);
  }

  public static void StartRectComment(FlatBufferBuilder builder) { builder.StartTable(5); }
  public static void AddMin(FlatBufferBuilder builder, Offset<AiEditor.Fb.Vector2> minOffset) { builder.AddOffset(0, minOffset.Value, 0); }
  public static void AddMax(FlatBufferBuilder builder, Offset<AiEditor.Fb.Vector2> maxOffset) { builder.AddOffset(1, maxOffset.Value, 0); }
  public static void AddColor(FlatBufferBuilder builder, Offset<AiEditor.Fb.Vector3> colorOffset) { builder.AddOffset(2, colorOffset.Value, 0); }
  public static void AddComment(FlatBufferBuilder builder, StringOffset commentOffset) { builder.AddOffset(3, commentOffset.Value, 0); }
  public static void AddIsLinkNode(FlatBufferBuilder builder, bool isLinkNode) { builder.AddBool(4, isLinkNode, false); }
  public static Offset<AiEditor.Fb.RectComment> EndRectComment(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<AiEditor.Fb.RectComment>(o);
  }
  public RectCommentT UnPack() {
    var _o = new RectCommentT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(RectCommentT _o) {
    _o.Min = this.Min.HasValue ? this.Min.Value.UnPack() : null;
    _o.Max = this.Max.HasValue ? this.Max.Value.UnPack() : null;
    _o.Color = this.Color.HasValue ? this.Color.Value.UnPack() : null;
    _o.Comment = this.Comment;
    _o.IsLinkNode = this.IsLinkNode;
  }
  public static Offset<AiEditor.Fb.RectComment> Pack(FlatBufferBuilder builder, RectCommentT _o) {
    if (_o == null) return default(Offset<AiEditor.Fb.RectComment>);
    var _min = _o.Min == null ? default(Offset<AiEditor.Fb.Vector2>) : AiEditor.Fb.Vector2.Pack(builder, _o.Min);
    var _max = _o.Max == null ? default(Offset<AiEditor.Fb.Vector2>) : AiEditor.Fb.Vector2.Pack(builder, _o.Max);
    var _color = _o.Color == null ? default(Offset<AiEditor.Fb.Vector3>) : AiEditor.Fb.Vector3.Pack(builder, _o.Color);
    var _comment = _o.Comment == null ? default(StringOffset) : builder.CreateString(_o.Comment);
    return CreateRectComment(
      builder,
      _min,
      _max,
      _color,
      _comment,
      _o.IsLinkNode);
  }
};

public class RectCommentT
{
  [Newtonsoft.Json.JsonProperty("min")]
  public AiEditor.Fb.Vector2T Min { get; set; }
  [Newtonsoft.Json.JsonProperty("max")]
  public AiEditor.Fb.Vector2T Max { get; set; }
  [Newtonsoft.Json.JsonProperty("color")]
  public AiEditor.Fb.Vector3T Color { get; set; }
  [Newtonsoft.Json.JsonProperty("comment")]
  public string Comment { get; set; }
  [Newtonsoft.Json.JsonProperty("isLinkNode")]
  public bool IsLinkNode { get; set; }

  public RectCommentT() {
    this.Min = null;
    this.Max = null;
    this.Color = null;
    this.Comment = null;
    this.IsLinkNode = false;
  }
}

public struct AEMeta : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static AEMeta GetRootAsAEMeta(ByteBuffer _bb) { return GetRootAsAEMeta(_bb, new AEMeta()); }
  public static AEMeta GetRootAsAEMeta(ByteBuffer _bb, AEMeta obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public AEMeta __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public AiEditor.Fb.NodeMeta? NodeMetas(int j) { int o = __p.__offset(4); return o != 0 ? (AiEditor.Fb.NodeMeta?)(new AiEditor.Fb.NodeMeta()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int NodeMetasLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
  public AiEditor.Fb.BgMeta? BgMeta { get { int o = __p.__offset(6); return o != 0 ? (AiEditor.Fb.BgMeta?)(new AiEditor.Fb.BgMeta()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public AiEditor.Fb.RectComment? RectComments(int j) { int o = __p.__offset(8); return o != 0 ? (AiEditor.Fb.RectComment?)(new AiEditor.Fb.RectComment()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int RectCommentsLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
  public AiEditor.Fb.FloatingNodes? FloatingNodes(int j) { int o = __p.__offset(10); return o != 0 ? (AiEditor.Fb.FloatingNodes?)(new AiEditor.Fb.FloatingNodes()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int FloatingNodesLength { get { int o = __p.__offset(10); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<AiEditor.Fb.AEMeta> CreateAEMeta(FlatBufferBuilder builder,
      VectorOffset nodeMetasOffset = default(VectorOffset),
      Offset<AiEditor.Fb.BgMeta> bgMetaOffset = default(Offset<AiEditor.Fb.BgMeta>),
      VectorOffset rectCommentsOffset = default(VectorOffset),
      VectorOffset floatingNodesOffset = default(VectorOffset)) {
    builder.StartTable(4);
    AEMeta.AddFloatingNodes(builder, floatingNodesOffset);
    AEMeta.AddRectComments(builder, rectCommentsOffset);
    AEMeta.AddBgMeta(builder, bgMetaOffset);
    AEMeta.AddNodeMetas(builder, nodeMetasOffset);
    return AEMeta.EndAEMeta(builder);
  }

  public static void StartAEMeta(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddNodeMetas(FlatBufferBuilder builder, VectorOffset nodeMetasOffset) { builder.AddOffset(0, nodeMetasOffset.Value, 0); }
  public static VectorOffset CreateNodeMetasVector(FlatBufferBuilder builder, Offset<AiEditor.Fb.NodeMeta>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateNodeMetasVectorBlock(FlatBufferBuilder builder, Offset<AiEditor.Fb.NodeMeta>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartNodeMetasVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddBgMeta(FlatBufferBuilder builder, Offset<AiEditor.Fb.BgMeta> bgMetaOffset) { builder.AddOffset(1, bgMetaOffset.Value, 0); }
  public static void AddRectComments(FlatBufferBuilder builder, VectorOffset rectCommentsOffset) { builder.AddOffset(2, rectCommentsOffset.Value, 0); }
  public static VectorOffset CreateRectCommentsVector(FlatBufferBuilder builder, Offset<AiEditor.Fb.RectComment>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateRectCommentsVectorBlock(FlatBufferBuilder builder, Offset<AiEditor.Fb.RectComment>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartRectCommentsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddFloatingNodes(FlatBufferBuilder builder, VectorOffset floatingNodesOffset) { builder.AddOffset(3, floatingNodesOffset.Value, 0); }
  public static VectorOffset CreateFloatingNodesVector(FlatBufferBuilder builder, Offset<AiEditor.Fb.FloatingNodes>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateFloatingNodesVectorBlock(FlatBufferBuilder builder, Offset<AiEditor.Fb.FloatingNodes>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartFloatingNodesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<AiEditor.Fb.AEMeta> EndAEMeta(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<AiEditor.Fb.AEMeta>(o);
  }
  public static void FinishAEMetaBuffer(FlatBufferBuilder builder, Offset<AiEditor.Fb.AEMeta> offset) { builder.Finish(offset.Value); }
  public static void FinishSizePrefixedAEMetaBuffer(FlatBufferBuilder builder, Offset<AiEditor.Fb.AEMeta> offset) { builder.FinishSizePrefixed(offset.Value); }
  public AEMetaT UnPack() {
    var _o = new AEMetaT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(AEMetaT _o) {
    _o.NodeMetas = new List<AiEditor.Fb.NodeMetaT>();
    for (var _j = 0; _j < this.NodeMetasLength; ++_j) {_o.NodeMetas.Add(this.NodeMetas(_j).HasValue ? this.NodeMetas(_j).Value.UnPack() : null);}
    _o.BgMeta = this.BgMeta.HasValue ? this.BgMeta.Value.UnPack() : null;
    _o.RectComments = new List<AiEditor.Fb.RectCommentT>();
    for (var _j = 0; _j < this.RectCommentsLength; ++_j) {_o.RectComments.Add(this.RectComments(_j).HasValue ? this.RectComments(_j).Value.UnPack() : null);}
    _o.FloatingNodes = new List<AiEditor.Fb.FloatingNodesT>();
    for (var _j = 0; _j < this.FloatingNodesLength; ++_j) {_o.FloatingNodes.Add(this.FloatingNodes(_j).HasValue ? this.FloatingNodes(_j).Value.UnPack() : null);}
  }
  public static Offset<AiEditor.Fb.AEMeta> Pack(FlatBufferBuilder builder, AEMetaT _o) {
    if (_o == null) return default(Offset<AiEditor.Fb.AEMeta>);
    var _nodeMetas = default(VectorOffset);
    if (_o.NodeMetas != null) {
      var __nodeMetas = new Offset<AiEditor.Fb.NodeMeta>[_o.NodeMetas.Count];
      for (var _j = 0; _j < __nodeMetas.Length; ++_j) { __nodeMetas[_j] = AiEditor.Fb.NodeMeta.Pack(builder, _o.NodeMetas[_j]); }
      _nodeMetas = CreateNodeMetasVector(builder, __nodeMetas);
    }
    var _bgMeta = _o.BgMeta == null ? default(Offset<AiEditor.Fb.BgMeta>) : AiEditor.Fb.BgMeta.Pack(builder, _o.BgMeta);
    var _rectComments = default(VectorOffset);
    if (_o.RectComments != null) {
      var __rectComments = new Offset<AiEditor.Fb.RectComment>[_o.RectComments.Count];
      for (var _j = 0; _j < __rectComments.Length; ++_j) { __rectComments[_j] = AiEditor.Fb.RectComment.Pack(builder, _o.RectComments[_j]); }
      _rectComments = CreateRectCommentsVector(builder, __rectComments);
    }
    var _floatingNodes = default(VectorOffset);
    if (_o.FloatingNodes != null) {
      var __floatingNodes = new Offset<AiEditor.Fb.FloatingNodes>[_o.FloatingNodes.Count];
      for (var _j = 0; _j < __floatingNodes.Length; ++_j) { __floatingNodes[_j] = AiEditor.Fb.FloatingNodes.Pack(builder, _o.FloatingNodes[_j]); }
      _floatingNodes = CreateFloatingNodesVector(builder, __floatingNodes);
    }
    return CreateAEMeta(
      builder,
      _nodeMetas,
      _bgMeta,
      _rectComments,
      _floatingNodes);
  }
};

public class AEMetaT
{
  [Newtonsoft.Json.JsonProperty("nodeMetas")]
  public List<AiEditor.Fb.NodeMetaT> NodeMetas { get; set; }
  [Newtonsoft.Json.JsonProperty("bgMeta")]
  public AiEditor.Fb.BgMetaT BgMeta { get; set; }
  [Newtonsoft.Json.JsonProperty("rectComments")]
  public List<AiEditor.Fb.RectCommentT> RectComments { get; set; }
  [Newtonsoft.Json.JsonProperty("floatingNodes")]
  public List<AiEditor.Fb.FloatingNodesT> FloatingNodes { get; set; }

  public AEMetaT() {
    this.NodeMetas = null;
    this.BgMeta = null;
    this.RectComments = null;
    this.FloatingNodes = null;
  }

  public static AEMetaT DeserializeFromJson(string jsonText) {
    return Newtonsoft.Json.JsonConvert.DeserializeObject<AEMetaT>(jsonText);
  }
  public string SerializeToJson() {
    return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
  }
  public static AEMetaT DeserializeFromBinary(byte[] fbBuffer) {
    return AEMeta.GetRootAsAEMeta(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    AEMeta.FinishAEMetaBuffer(fbb, AEMeta.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


}
