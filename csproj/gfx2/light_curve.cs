// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace gfl.gfx2.fb
{

using global::System;
using global::System.Collections.Generic;
using global::FlatBuffers;

[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
public enum CurveInterpType : uint
{
  Constant = 0,
  Linear = 1,
  TangentAuto = 2,
  TangentBreak = 3,
  TangentUser = 4,
};

public struct RuntimeCurveKey : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static RuntimeCurveKey GetRootAsRuntimeCurveKey(ByteBuffer _bb) { return GetRootAsRuntimeCurveKey(_bb, new RuntimeCurveKey()); }
  public static RuntimeCurveKey GetRootAsRuntimeCurveKey(ByteBuffer _bb, RuntimeCurveKey obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RuntimeCurveKey __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float Time { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float Value { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float TangentLeft { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float TangentRight { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public gfl.gfx2.fb.CurveInterpType InterpType { get { int o = __p.__offset(12); return o != 0 ? (gfl.gfx2.fb.CurveInterpType)__p.bb.GetUint(o + __p.bb_pos) : gfl.gfx2.fb.CurveInterpType.Constant; } }

  public static Offset<gfl.gfx2.fb.RuntimeCurveKey> CreateRuntimeCurveKey(FlatBufferBuilder builder,
      float time = 0.0f,
      float value = 0.0f,
      float tangentLeft = 0.0f,
      float tangentRight = 0.0f,
      gfl.gfx2.fb.CurveInterpType interpType = gfl.gfx2.fb.CurveInterpType.Constant) {
    builder.StartTable(5);
    RuntimeCurveKey.AddInterpType(builder, interpType);
    RuntimeCurveKey.AddTangentRight(builder, tangentRight);
    RuntimeCurveKey.AddTangentLeft(builder, tangentLeft);
    RuntimeCurveKey.AddValue(builder, value);
    RuntimeCurveKey.AddTime(builder, time);
    return RuntimeCurveKey.EndRuntimeCurveKey(builder);
  }

  public static void StartRuntimeCurveKey(FlatBufferBuilder builder) { builder.StartTable(5); }
  public static void AddTime(FlatBufferBuilder builder, float time) { builder.AddFloat(0, time, 0.0f); }
  public static void AddValue(FlatBufferBuilder builder, float value) { builder.AddFloat(1, value, 0.0f); }
  public static void AddTangentLeft(FlatBufferBuilder builder, float tangentLeft) { builder.AddFloat(2, tangentLeft, 0.0f); }
  public static void AddTangentRight(FlatBufferBuilder builder, float tangentRight) { builder.AddFloat(3, tangentRight, 0.0f); }
  public static void AddInterpType(FlatBufferBuilder builder, gfl.gfx2.fb.CurveInterpType interpType) { builder.AddUint(4, (uint)interpType, 0); }
  public static Offset<gfl.gfx2.fb.RuntimeCurveKey> EndRuntimeCurveKey(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.gfx2.fb.RuntimeCurveKey>(o);
  }
  public RuntimeCurveKeyT UnPack() {
    var _o = new RuntimeCurveKeyT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(RuntimeCurveKeyT _o) {
    _o.Time = this.Time;
    _o.Value = this.Value;
    _o.TangentLeft = this.TangentLeft;
    _o.TangentRight = this.TangentRight;
    _o.InterpType = this.InterpType;
  }
  public static Offset<gfl.gfx2.fb.RuntimeCurveKey> Pack(FlatBufferBuilder builder, RuntimeCurveKeyT _o) {
    if (_o == null) return default(Offset<gfl.gfx2.fb.RuntimeCurveKey>);
    return CreateRuntimeCurveKey(
      builder,
      _o.Time,
      _o.Value,
      _o.TangentLeft,
      _o.TangentRight,
      _o.InterpType);
  }
};

public class RuntimeCurveKeyT
{
  [Newtonsoft.Json.JsonProperty("time")]
  public float Time { get; set; }
  [Newtonsoft.Json.JsonProperty("value")]
  public float Value { get; set; }
  [Newtonsoft.Json.JsonProperty("tangentLeft")]
  public float TangentLeft { get; set; }
  [Newtonsoft.Json.JsonProperty("tangentRight")]
  public float TangentRight { get; set; }
  [Newtonsoft.Json.JsonProperty("interpType")]
  public gfl.gfx2.fb.CurveInterpType InterpType { get; set; }

  public RuntimeCurveKeyT() {
    this.Time = 0.0f;
    this.Value = 0.0f;
    this.TangentLeft = 0.0f;
    this.TangentRight = 0.0f;
    this.InterpType = gfl.gfx2.fb.CurveInterpType.Constant;
  }
}

public struct RuntimeCurveFloat : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static RuntimeCurveFloat GetRootAsRuntimeCurveFloat(ByteBuffer _bb) { return GetRootAsRuntimeCurveFloat(_bb, new RuntimeCurveFloat()); }
  public static RuntimeCurveFloat GetRootAsRuntimeCurveFloat(ByteBuffer _bb, RuntimeCurveFloat obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RuntimeCurveFloat __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public gfl.gfx2.fb.RuntimeCurveKey? Keys(int j) { int o = __p.__offset(4); return o != 0 ? (gfl.gfx2.fb.RuntimeCurveKey?)(new gfl.gfx2.fb.RuntimeCurveKey()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int KeysLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<gfl.gfx2.fb.RuntimeCurveFloat> CreateRuntimeCurveFloat(FlatBufferBuilder builder,
      VectorOffset keysOffset = default(VectorOffset)) {
    builder.StartTable(1);
    RuntimeCurveFloat.AddKeys(builder, keysOffset);
    return RuntimeCurveFloat.EndRuntimeCurveFloat(builder);
  }

  public static void StartRuntimeCurveFloat(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddKeys(FlatBufferBuilder builder, VectorOffset keysOffset) { builder.AddOffset(0, keysOffset.Value, 0); }
  public static VectorOffset CreateKeysVector(FlatBufferBuilder builder, Offset<gfl.gfx2.fb.RuntimeCurveKey>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateKeysVectorBlock(FlatBufferBuilder builder, Offset<gfl.gfx2.fb.RuntimeCurveKey>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartKeysVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<gfl.gfx2.fb.RuntimeCurveFloat> EndRuntimeCurveFloat(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.gfx2.fb.RuntimeCurveFloat>(o);
  }
  public RuntimeCurveFloatT UnPack() {
    var _o = new RuntimeCurveFloatT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(RuntimeCurveFloatT _o) {
    _o.Keys = new List<gfl.gfx2.fb.RuntimeCurveKeyT>();
    for (var _j = 0; _j < this.KeysLength; ++_j) {_o.Keys.Add(this.Keys(_j).HasValue ? this.Keys(_j).Value.UnPack() : null);}
  }
  public static Offset<gfl.gfx2.fb.RuntimeCurveFloat> Pack(FlatBufferBuilder builder, RuntimeCurveFloatT _o) {
    if (_o == null) return default(Offset<gfl.gfx2.fb.RuntimeCurveFloat>);
    var _keys = default(VectorOffset);
    if (_o.Keys != null) {
      var __keys = new Offset<gfl.gfx2.fb.RuntimeCurveKey>[_o.Keys.Count];
      for (var _j = 0; _j < __keys.Length; ++_j) { __keys[_j] = gfl.gfx2.fb.RuntimeCurveKey.Pack(builder, _o.Keys[_j]); }
      _keys = CreateKeysVector(builder, __keys);
    }
    return CreateRuntimeCurveFloat(
      builder,
      _keys);
  }
};

public class RuntimeCurveFloatT
{
  [Newtonsoft.Json.JsonProperty("keys")]
  public List<gfl.gfx2.fb.RuntimeCurveKeyT> Keys { get; set; }

  public RuntimeCurveFloatT() {
    this.Keys = null;
  }
}

public struct RuntimeCurveFloat4 : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static RuntimeCurveFloat4 GetRootAsRuntimeCurveFloat4(ByteBuffer _bb) { return GetRootAsRuntimeCurveFloat4(_bb, new RuntimeCurveFloat4()); }
  public static RuntimeCurveFloat4 GetRootAsRuntimeCurveFloat4(ByteBuffer _bb, RuntimeCurveFloat4 obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RuntimeCurveFloat4 __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public gfl.gfx2.fb.RuntimeCurveFloat? X { get { int o = __p.__offset(4); return o != 0 ? (gfl.gfx2.fb.RuntimeCurveFloat?)(new gfl.gfx2.fb.RuntimeCurveFloat()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public gfl.gfx2.fb.RuntimeCurveFloat? Y { get { int o = __p.__offset(6); return o != 0 ? (gfl.gfx2.fb.RuntimeCurveFloat?)(new gfl.gfx2.fb.RuntimeCurveFloat()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public gfl.gfx2.fb.RuntimeCurveFloat? Z { get { int o = __p.__offset(8); return o != 0 ? (gfl.gfx2.fb.RuntimeCurveFloat?)(new gfl.gfx2.fb.RuntimeCurveFloat()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public gfl.gfx2.fb.RuntimeCurveFloat? W { get { int o = __p.__offset(10); return o != 0 ? (gfl.gfx2.fb.RuntimeCurveFloat?)(new gfl.gfx2.fb.RuntimeCurveFloat()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }

  public static Offset<gfl.gfx2.fb.RuntimeCurveFloat4> CreateRuntimeCurveFloat4(FlatBufferBuilder builder,
      Offset<gfl.gfx2.fb.RuntimeCurveFloat> xOffset = default(Offset<gfl.gfx2.fb.RuntimeCurveFloat>),
      Offset<gfl.gfx2.fb.RuntimeCurveFloat> yOffset = default(Offset<gfl.gfx2.fb.RuntimeCurveFloat>),
      Offset<gfl.gfx2.fb.RuntimeCurveFloat> zOffset = default(Offset<gfl.gfx2.fb.RuntimeCurveFloat>),
      Offset<gfl.gfx2.fb.RuntimeCurveFloat> wOffset = default(Offset<gfl.gfx2.fb.RuntimeCurveFloat>)) {
    builder.StartTable(4);
    RuntimeCurveFloat4.AddW(builder, wOffset);
    RuntimeCurveFloat4.AddZ(builder, zOffset);
    RuntimeCurveFloat4.AddY(builder, yOffset);
    RuntimeCurveFloat4.AddX(builder, xOffset);
    return RuntimeCurveFloat4.EndRuntimeCurveFloat4(builder);
  }

  public static void StartRuntimeCurveFloat4(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddX(FlatBufferBuilder builder, Offset<gfl.gfx2.fb.RuntimeCurveFloat> xOffset) { builder.AddOffset(0, xOffset.Value, 0); }
  public static void AddY(FlatBufferBuilder builder, Offset<gfl.gfx2.fb.RuntimeCurveFloat> yOffset) { builder.AddOffset(1, yOffset.Value, 0); }
  public static void AddZ(FlatBufferBuilder builder, Offset<gfl.gfx2.fb.RuntimeCurveFloat> zOffset) { builder.AddOffset(2, zOffset.Value, 0); }
  public static void AddW(FlatBufferBuilder builder, Offset<gfl.gfx2.fb.RuntimeCurveFloat> wOffset) { builder.AddOffset(3, wOffset.Value, 0); }
  public static Offset<gfl.gfx2.fb.RuntimeCurveFloat4> EndRuntimeCurveFloat4(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.gfx2.fb.RuntimeCurveFloat4>(o);
  }
  public RuntimeCurveFloat4T UnPack() {
    var _o = new RuntimeCurveFloat4T();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(RuntimeCurveFloat4T _o) {
    _o.X = this.X.HasValue ? this.X.Value.UnPack() : null;
    _o.Y = this.Y.HasValue ? this.Y.Value.UnPack() : null;
    _o.Z = this.Z.HasValue ? this.Z.Value.UnPack() : null;
    _o.W = this.W.HasValue ? this.W.Value.UnPack() : null;
  }
  public static Offset<gfl.gfx2.fb.RuntimeCurveFloat4> Pack(FlatBufferBuilder builder, RuntimeCurveFloat4T _o) {
    if (_o == null) return default(Offset<gfl.gfx2.fb.RuntimeCurveFloat4>);
    var _x = _o.X == null ? default(Offset<gfl.gfx2.fb.RuntimeCurveFloat>) : gfl.gfx2.fb.RuntimeCurveFloat.Pack(builder, _o.X);
    var _y = _o.Y == null ? default(Offset<gfl.gfx2.fb.RuntimeCurveFloat>) : gfl.gfx2.fb.RuntimeCurveFloat.Pack(builder, _o.Y);
    var _z = _o.Z == null ? default(Offset<gfl.gfx2.fb.RuntimeCurveFloat>) : gfl.gfx2.fb.RuntimeCurveFloat.Pack(builder, _o.Z);
    var _w = _o.W == null ? default(Offset<gfl.gfx2.fb.RuntimeCurveFloat>) : gfl.gfx2.fb.RuntimeCurveFloat.Pack(builder, _o.W);
    return CreateRuntimeCurveFloat4(
      builder,
      _x,
      _y,
      _z,
      _w);
  }
};

public class RuntimeCurveFloat4T
{
  [Newtonsoft.Json.JsonProperty("x")]
  public gfl.gfx2.fb.RuntimeCurveFloatT X { get; set; }
  [Newtonsoft.Json.JsonProperty("y")]
  public gfl.gfx2.fb.RuntimeCurveFloatT Y { get; set; }
  [Newtonsoft.Json.JsonProperty("z")]
  public gfl.gfx2.fb.RuntimeCurveFloatT Z { get; set; }
  [Newtonsoft.Json.JsonProperty("w")]
  public gfl.gfx2.fb.RuntimeCurveFloatT W { get; set; }

  public RuntimeCurveFloat4T() {
    this.X = null;
    this.Y = null;
    this.Z = null;
    this.W = null;
  }
}


}
