// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace gfl.scene.fb
{

using global::System;
using global::System.Collections.Generic;
using global::FlatBuffers;

[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
public enum CollisionShapeData : byte
{
  NONE = 0,
  SphereShape = 1,
  BoxShape = 2,
  CapsuleShape = 3,
  ModelShape = 4,
  CompoundShape = 5,
  PencilShape = 6,
};

public class CollisionShapeDataUnion {
  public CollisionShapeData Type { get; set; }
  public object Value { get; set; }

  public CollisionShapeDataUnion() {
    this.Type = CollisionShapeData.NONE;
    this.Value = null;
  }

  public T As<T>() where T : class { return this.Value as T; }
  public gfl.scene.fb.SphereShapeT AsSphereShape() { return this.As<gfl.scene.fb.SphereShapeT>(); }
  public gfl.scene.fb.BoxShapeT AsBoxShape() { return this.As<gfl.scene.fb.BoxShapeT>(); }
  public gfl.scene.fb.CapsuleShapeT AsCapsuleShape() { return this.As<gfl.scene.fb.CapsuleShapeT>(); }
  public gfl.scene.fb.ModelShapeT AsModelShape() { return this.As<gfl.scene.fb.ModelShapeT>(); }
  public gfl.scene.fb.CompoundShapeT AsCompoundShape() { return this.As<gfl.scene.fb.CompoundShapeT>(); }
  public gfl.scene.fb.PencilShapeT AsPencilShape() { return this.As<gfl.scene.fb.PencilShapeT>(); }

  public static int Pack(FlatBuffers.FlatBufferBuilder builder, CollisionShapeDataUnion _o) {
    switch (_o.Type) {
      default: return 0;
      case CollisionShapeData.SphereShape: return gfl.scene.fb.SphereShape.Pack(builder, _o.AsSphereShape()).Value;
      case CollisionShapeData.BoxShape: return gfl.scene.fb.BoxShape.Pack(builder, _o.AsBoxShape()).Value;
      case CollisionShapeData.CapsuleShape: return gfl.scene.fb.CapsuleShape.Pack(builder, _o.AsCapsuleShape()).Value;
      case CollisionShapeData.ModelShape: return gfl.scene.fb.ModelShape.Pack(builder, _o.AsModelShape()).Value;
      case CollisionShapeData.CompoundShape: return gfl.scene.fb.CompoundShape.Pack(builder, _o.AsCompoundShape()).Value;
      case CollisionShapeData.PencilShape: return gfl.scene.fb.PencilShape.Pack(builder, _o.AsPencilShape()).Value;
    }
  }
}

public class CollisionShapeDataUnion_JsonConverter : Newtonsoft.Json.JsonConverter {
  public override bool CanConvert(System.Type objectType) {
    return objectType == typeof(CollisionShapeDataUnion) || objectType == typeof(System.Collections.Generic.List<CollisionShapeDataUnion>);
  }
  public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object value, Newtonsoft.Json.JsonSerializer serializer) {
    var _olist = value as System.Collections.Generic.List<CollisionShapeDataUnion>;
    if (_olist != null) {
      writer.WriteStartArray();
      foreach (var _o in _olist) { this.WriteJson(writer, _o, serializer); }
      writer.WriteEndArray();
    } else {
      this.WriteJson(writer, value as CollisionShapeDataUnion, serializer);
    }
  }
  public void WriteJson(Newtonsoft.Json.JsonWriter writer, CollisionShapeDataUnion _o, Newtonsoft.Json.JsonSerializer serializer) {
    if (_o == null) return;
    serializer.Serialize(writer, _o.Value);
  }
  public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type objectType, object existingValue, Newtonsoft.Json.JsonSerializer serializer) {
    var _olist = existingValue as System.Collections.Generic.List<CollisionShapeDataUnion>;
    if (_olist != null) {
      for (var _j = 0; _j < _olist.Count; ++_j) {
        reader.Read();
        _olist[_j] = this.ReadJson(reader, _olist[_j], serializer);
      }
      reader.Read();
      return _olist;
    } else {
      return this.ReadJson(reader, existingValue as CollisionShapeDataUnion, serializer);
    }
  }
  public CollisionShapeDataUnion ReadJson(Newtonsoft.Json.JsonReader reader, CollisionShapeDataUnion _o, Newtonsoft.Json.JsonSerializer serializer) {
    if (_o == null) return null;
    switch (_o.Type) {
      default: break;
      case CollisionShapeData.SphereShape: _o.Value = serializer.Deserialize<gfl.scene.fb.SphereShapeT>(reader); break;
      case CollisionShapeData.BoxShape: _o.Value = serializer.Deserialize<gfl.scene.fb.BoxShapeT>(reader); break;
      case CollisionShapeData.CapsuleShape: _o.Value = serializer.Deserialize<gfl.scene.fb.CapsuleShapeT>(reader); break;
      case CollisionShapeData.ModelShape: _o.Value = serializer.Deserialize<gfl.scene.fb.ModelShapeT>(reader); break;
      case CollisionShapeData.CompoundShape: _o.Value = serializer.Deserialize<gfl.scene.fb.CompoundShapeT>(reader); break;
      case CollisionShapeData.PencilShape: _o.Value = serializer.Deserialize<gfl.scene.fb.PencilShapeT>(reader); break;
    }
    return _o;
  }
}

public struct SphereShape : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static SphereShape GetRootAsSphereShape(ByteBuffer _bb) { return GetRootAsSphereShape(_bb, new SphereShape()); }
  public static SphereShape GetRootAsSphereShape(ByteBuffer _bb, SphereShape obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SphereShape __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public gfl.math.fb.Vector3f? Pos { get { int o = __p.__offset(4); return o != 0 ? (gfl.math.fb.Vector3f?)(new gfl.math.fb.Vector3f()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public float Radius { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<gfl.scene.fb.SphereShape> CreateSphereShape(FlatBufferBuilder builder,
      gfl.math.fb.Vector3fT pos = null,
      float radius = 0.0f) {
    builder.StartTable(2);
    SphereShape.AddRadius(builder, radius);
    SphereShape.AddPos(builder, gfl.math.fb.Vector3f.Pack(builder, pos));
    return SphereShape.EndSphereShape(builder);
  }

  public static void StartSphereShape(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddPos(FlatBufferBuilder builder, Offset<gfl.math.fb.Vector3f> posOffset) { builder.AddStruct(0, posOffset.Value, 0); }
  public static void AddRadius(FlatBufferBuilder builder, float radius) { builder.AddFloat(1, radius, 0.0f); }
  public static Offset<gfl.scene.fb.SphereShape> EndSphereShape(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.scene.fb.SphereShape>(o);
  }
  public SphereShapeT UnPack() {
    var _o = new SphereShapeT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(SphereShapeT _o) {
    _o.Pos = this.Pos.HasValue ? this.Pos.Value.UnPack() : null;
    _o.Radius = this.Radius;
  }
  public static Offset<gfl.scene.fb.SphereShape> Pack(FlatBufferBuilder builder, SphereShapeT _o) {
    if (_o == null) return default(Offset<gfl.scene.fb.SphereShape>);
    return CreateSphereShape(
      builder,
      _o.Pos,
      _o.Radius);
  }
};

public class SphereShapeT
{
  [Newtonsoft.Json.JsonProperty("pos")]
  public gfl.math.fb.Vector3fT Pos { get; set; }
  [Newtonsoft.Json.JsonProperty("radius")]
  public float Radius { get; set; }

  public SphereShapeT() {
    this.Pos = new gfl.math.fb.Vector3fT();
    this.Radius = 0.0f;
  }
}

public struct BoxShape : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static BoxShape GetRootAsBoxShape(ByteBuffer _bb) { return GetRootAsBoxShape(_bb, new BoxShape()); }
  public static BoxShape GetRootAsBoxShape(ByteBuffer _bb, BoxShape obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BoxShape __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public gfl.math.fb.Vector3f? Pos { get { int o = __p.__offset(4); return o != 0 ? (gfl.math.fb.Vector3f?)(new gfl.math.fb.Vector3f()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public gfl.math.fb.Vector3f? Extend { get { int o = __p.__offset(6); return o != 0 ? (gfl.math.fb.Vector3f?)(new gfl.math.fb.Vector3f()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public gfl.math.fb.Vector3f? Rot { get { int o = __p.__offset(8); return o != 0 ? (gfl.math.fb.Vector3f?)(new gfl.math.fb.Vector3f()).__assign(o + __p.bb_pos, __p.bb) : null; } }

  public static void StartBoxShape(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddPos(FlatBufferBuilder builder, Offset<gfl.math.fb.Vector3f> posOffset) { builder.AddStruct(0, posOffset.Value, 0); }
  public static void AddExtend(FlatBufferBuilder builder, Offset<gfl.math.fb.Vector3f> extendOffset) { builder.AddStruct(1, extendOffset.Value, 0); }
  public static void AddRot(FlatBufferBuilder builder, Offset<gfl.math.fb.Vector3f> rotOffset) { builder.AddStruct(2, rotOffset.Value, 0); }
  public static Offset<gfl.scene.fb.BoxShape> EndBoxShape(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.scene.fb.BoxShape>(o);
  }
  public BoxShapeT UnPack() {
    var _o = new BoxShapeT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(BoxShapeT _o) {
    _o.Pos = this.Pos.HasValue ? this.Pos.Value.UnPack() : null;
    _o.Extend = this.Extend.HasValue ? this.Extend.Value.UnPack() : null;
    _o.Rot = this.Rot.HasValue ? this.Rot.Value.UnPack() : null;
  }
  public static Offset<gfl.scene.fb.BoxShape> Pack(FlatBufferBuilder builder, BoxShapeT _o) {
    if (_o == null) return default(Offset<gfl.scene.fb.BoxShape>);
    StartBoxShape(builder);
    AddPos(builder, gfl.math.fb.Vector3f.Pack(builder, _o.Pos));
    AddExtend(builder, gfl.math.fb.Vector3f.Pack(builder, _o.Extend));
    AddRot(builder, gfl.math.fb.Vector3f.Pack(builder, _o.Rot));
    return EndBoxShape(builder);
  }
};

public class BoxShapeT
{
  [Newtonsoft.Json.JsonProperty("pos")]
  public gfl.math.fb.Vector3fT Pos { get; set; }
  [Newtonsoft.Json.JsonProperty("extend")]
  public gfl.math.fb.Vector3fT Extend { get; set; }
  [Newtonsoft.Json.JsonProperty("rot")]
  public gfl.math.fb.Vector3fT Rot { get; set; }

  public BoxShapeT() {
    this.Pos = new gfl.math.fb.Vector3fT();
    this.Extend = new gfl.math.fb.Vector3fT();
    this.Rot = new gfl.math.fb.Vector3fT();
  }
}

public struct CapsuleShape : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static CapsuleShape GetRootAsCapsuleShape(ByteBuffer _bb) { return GetRootAsCapsuleShape(_bb, new CapsuleShape()); }
  public static CapsuleShape GetRootAsCapsuleShape(ByteBuffer _bb, CapsuleShape obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public CapsuleShape __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public gfl.math.fb.Vector3f? Pos { get { int o = __p.__offset(4); return o != 0 ? (gfl.math.fb.Vector3f?)(new gfl.math.fb.Vector3f()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public float Radius { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float Height { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public gfl.math.fb.Vector3f? Rot { get { int o = __p.__offset(10); return o != 0 ? (gfl.math.fb.Vector3f?)(new gfl.math.fb.Vector3f()).__assign(o + __p.bb_pos, __p.bb) : null; } }

  public static Offset<gfl.scene.fb.CapsuleShape> CreateCapsuleShape(FlatBufferBuilder builder,
      gfl.math.fb.Vector3fT pos = null,
      float radius = 0.0f,
      float height = 0.0f,
      gfl.math.fb.Vector3fT rot = null) {
    builder.StartTable(4);
    CapsuleShape.AddRot(builder, gfl.math.fb.Vector3f.Pack(builder, rot));
    CapsuleShape.AddHeight(builder, height);
    CapsuleShape.AddRadius(builder, radius);
    CapsuleShape.AddPos(builder, gfl.math.fb.Vector3f.Pack(builder, pos));
    return CapsuleShape.EndCapsuleShape(builder);
  }

  public static void StartCapsuleShape(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddPos(FlatBufferBuilder builder, Offset<gfl.math.fb.Vector3f> posOffset) { builder.AddStruct(0, posOffset.Value, 0); }
  public static void AddRadius(FlatBufferBuilder builder, float radius) { builder.AddFloat(1, radius, 0.0f); }
  public static void AddHeight(FlatBufferBuilder builder, float height) { builder.AddFloat(2, height, 0.0f); }
  public static void AddRot(FlatBufferBuilder builder, Offset<gfl.math.fb.Vector3f> rotOffset) { builder.AddStruct(3, rotOffset.Value, 0); }
  public static Offset<gfl.scene.fb.CapsuleShape> EndCapsuleShape(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.scene.fb.CapsuleShape>(o);
  }
  public CapsuleShapeT UnPack() {
    var _o = new CapsuleShapeT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(CapsuleShapeT _o) {
    _o.Pos = this.Pos.HasValue ? this.Pos.Value.UnPack() : null;
    _o.Radius = this.Radius;
    _o.Height = this.Height;
    _o.Rot = this.Rot.HasValue ? this.Rot.Value.UnPack() : null;
  }
  public static Offset<gfl.scene.fb.CapsuleShape> Pack(FlatBufferBuilder builder, CapsuleShapeT _o) {
    if (_o == null) return default(Offset<gfl.scene.fb.CapsuleShape>);
    return CreateCapsuleShape(
      builder,
      _o.Pos,
      _o.Radius,
      _o.Height,
      _o.Rot);
  }
};

public class CapsuleShapeT
{
  [Newtonsoft.Json.JsonProperty("pos")]
  public gfl.math.fb.Vector3fT Pos { get; set; }
  [Newtonsoft.Json.JsonProperty("radius")]
  public float Radius { get; set; }
  [Newtonsoft.Json.JsonProperty("height")]
  public float Height { get; set; }
  [Newtonsoft.Json.JsonProperty("rot")]
  public gfl.math.fb.Vector3fT Rot { get; set; }

  public CapsuleShapeT() {
    this.Pos = new gfl.math.fb.Vector3fT();
    this.Radius = 0.0f;
    this.Height = 0.0f;
    this.Rot = new gfl.math.fb.Vector3fT();
  }
}

public struct ModelShape : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static ModelShape GetRootAsModelShape(ByteBuffer _bb) { return GetRootAsModelShape(_bb, new ModelShape()); }
  public static ModelShape GetRootAsModelShape(ByteBuffer _bb, ModelShape obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ModelShape __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string ModelFilePath { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetModelFilePathBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetModelFilePathBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetModelFilePathArray() { return __p.__vector_as_array<byte>(4); }
  public gfl.math.fb.Vector3f? Pos { get { int o = __p.__offset(6); return o != 0 ? (gfl.math.fb.Vector3f?)(new gfl.math.fb.Vector3f()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public gfl.math.fb.Vector3f? Rot { get { int o = __p.__offset(8); return o != 0 ? (gfl.math.fb.Vector3f?)(new gfl.math.fb.Vector3f()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public gfl.math.fb.Vector3f? Scale { get { int o = __p.__offset(10); return o != 0 ? (gfl.math.fb.Vector3f?)(new gfl.math.fb.Vector3f()).__assign(o + __p.bb_pos, __p.bb) : null; } }

  public static Offset<gfl.scene.fb.ModelShape> CreateModelShape(FlatBufferBuilder builder,
      StringOffset modelFilePathOffset = default(StringOffset),
      gfl.math.fb.Vector3fT pos = null,
      gfl.math.fb.Vector3fT rot = null,
      gfl.math.fb.Vector3fT scale = null) {
    builder.StartTable(4);
    ModelShape.AddScale(builder, gfl.math.fb.Vector3f.Pack(builder, scale));
    ModelShape.AddRot(builder, gfl.math.fb.Vector3f.Pack(builder, rot));
    ModelShape.AddPos(builder, gfl.math.fb.Vector3f.Pack(builder, pos));
    ModelShape.AddModelFilePath(builder, modelFilePathOffset);
    return ModelShape.EndModelShape(builder);
  }

  public static void StartModelShape(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddModelFilePath(FlatBufferBuilder builder, StringOffset modelFilePathOffset) { builder.AddOffset(0, modelFilePathOffset.Value, 0); }
  public static void AddPos(FlatBufferBuilder builder, Offset<gfl.math.fb.Vector3f> posOffset) { builder.AddStruct(1, posOffset.Value, 0); }
  public static void AddRot(FlatBufferBuilder builder, Offset<gfl.math.fb.Vector3f> rotOffset) { builder.AddStruct(2, rotOffset.Value, 0); }
  public static void AddScale(FlatBufferBuilder builder, Offset<gfl.math.fb.Vector3f> scaleOffset) { builder.AddStruct(3, scaleOffset.Value, 0); }
  public static Offset<gfl.scene.fb.ModelShape> EndModelShape(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.scene.fb.ModelShape>(o);
  }
  public ModelShapeT UnPack() {
    var _o = new ModelShapeT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(ModelShapeT _o) {
    _o.ModelFilePath = this.ModelFilePath;
    _o.Pos = this.Pos.HasValue ? this.Pos.Value.UnPack() : null;
    _o.Rot = this.Rot.HasValue ? this.Rot.Value.UnPack() : null;
    _o.Scale = this.Scale.HasValue ? this.Scale.Value.UnPack() : null;
  }
  public static Offset<gfl.scene.fb.ModelShape> Pack(FlatBufferBuilder builder, ModelShapeT _o) {
    if (_o == null) return default(Offset<gfl.scene.fb.ModelShape>);
    var _modelFilePath = _o.ModelFilePath == null ? default(StringOffset) : builder.CreateString(_o.ModelFilePath);
    return CreateModelShape(
      builder,
      _modelFilePath,
      _o.Pos,
      _o.Rot,
      _o.Scale);
  }
};

public class ModelShapeT
{
  [Newtonsoft.Json.JsonProperty("modelFilePath")]
  public string ModelFilePath { get; set; }
  [Newtonsoft.Json.JsonProperty("pos")]
  public gfl.math.fb.Vector3fT Pos { get; set; }
  [Newtonsoft.Json.JsonProperty("rot")]
  public gfl.math.fb.Vector3fT Rot { get; set; }
  [Newtonsoft.Json.JsonProperty("scale")]
  public gfl.math.fb.Vector3fT Scale { get; set; }

  public ModelShapeT() {
    this.ModelFilePath = null;
    this.Pos = new gfl.math.fb.Vector3fT();
    this.Rot = new gfl.math.fb.Vector3fT();
    this.Scale = new gfl.math.fb.Vector3fT();
  }
}

public struct CompoundShape : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static CompoundShape GetRootAsCompoundShape(ByteBuffer _bb) { return GetRootAsCompoundShape(_bb, new CompoundShape()); }
  public static CompoundShape GetRootAsCompoundShape(ByteBuffer _bb, CompoundShape obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public CompoundShape __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartCompoundShape(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<gfl.scene.fb.CompoundShape> EndCompoundShape(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.scene.fb.CompoundShape>(o);
  }
  public CompoundShapeT UnPack() {
    var _o = new CompoundShapeT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(CompoundShapeT _o) {
  }
  public static Offset<gfl.scene.fb.CompoundShape> Pack(FlatBufferBuilder builder, CompoundShapeT _o) {
    if (_o == null) return default(Offset<gfl.scene.fb.CompoundShape>);
    StartCompoundShape(builder);
    return EndCompoundShape(builder);
  }
};

public class CompoundShapeT
{

  public CompoundShapeT() {
  }
}

public struct PencilShape : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static PencilShape GetRootAsPencilShape(ByteBuffer _bb) { return GetRootAsPencilShape(_bb, new PencilShape()); }
  public static PencilShape GetRootAsPencilShape(ByteBuffer _bb, PencilShape obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PencilShape __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public gfl.math.fb.Vector3f? Pos { get { int o = __p.__offset(4); return o != 0 ? (gfl.math.fb.Vector3f?)(new gfl.math.fb.Vector3f()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public float Radius { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float CylinderHeight { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float TipHeight { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public int SliceCount { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public gfl.math.fb.Vector3f? Rot { get { int o = __p.__offset(14); return o != 0 ? (gfl.math.fb.Vector3f?)(new gfl.math.fb.Vector3f()).__assign(o + __p.bb_pos, __p.bb) : null; } }

  public static Offset<gfl.scene.fb.PencilShape> CreatePencilShape(FlatBufferBuilder builder,
      gfl.math.fb.Vector3fT pos = null,
      float radius = 0.0f,
      float cylinderHeight = 0.0f,
      float tipHeight = 0.0f,
      int sliceCount = 0,
      gfl.math.fb.Vector3fT rot = null) {
    builder.StartTable(6);
    PencilShape.AddRot(builder, gfl.math.fb.Vector3f.Pack(builder, rot));
    PencilShape.AddSliceCount(builder, sliceCount);
    PencilShape.AddTipHeight(builder, tipHeight);
    PencilShape.AddCylinderHeight(builder, cylinderHeight);
    PencilShape.AddRadius(builder, radius);
    PencilShape.AddPos(builder, gfl.math.fb.Vector3f.Pack(builder, pos));
    return PencilShape.EndPencilShape(builder);
  }

  public static void StartPencilShape(FlatBufferBuilder builder) { builder.StartTable(6); }
  public static void AddPos(FlatBufferBuilder builder, Offset<gfl.math.fb.Vector3f> posOffset) { builder.AddStruct(0, posOffset.Value, 0); }
  public static void AddRadius(FlatBufferBuilder builder, float radius) { builder.AddFloat(1, radius, 0.0f); }
  public static void AddCylinderHeight(FlatBufferBuilder builder, float cylinderHeight) { builder.AddFloat(2, cylinderHeight, 0.0f); }
  public static void AddTipHeight(FlatBufferBuilder builder, float tipHeight) { builder.AddFloat(3, tipHeight, 0.0f); }
  public static void AddSliceCount(FlatBufferBuilder builder, int sliceCount) { builder.AddInt(4, sliceCount, 0); }
  public static void AddRot(FlatBufferBuilder builder, Offset<gfl.math.fb.Vector3f> rotOffset) { builder.AddStruct(5, rotOffset.Value, 0); }
  public static Offset<gfl.scene.fb.PencilShape> EndPencilShape(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.scene.fb.PencilShape>(o);
  }
  public PencilShapeT UnPack() {
    var _o = new PencilShapeT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(PencilShapeT _o) {
    _o.Pos = this.Pos.HasValue ? this.Pos.Value.UnPack() : null;
    _o.Radius = this.Radius;
    _o.CylinderHeight = this.CylinderHeight;
    _o.TipHeight = this.TipHeight;
    _o.SliceCount = this.SliceCount;
    _o.Rot = this.Rot.HasValue ? this.Rot.Value.UnPack() : null;
  }
  public static Offset<gfl.scene.fb.PencilShape> Pack(FlatBufferBuilder builder, PencilShapeT _o) {
    if (_o == null) return default(Offset<gfl.scene.fb.PencilShape>);
    return CreatePencilShape(
      builder,
      _o.Pos,
      _o.Radius,
      _o.CylinderHeight,
      _o.TipHeight,
      _o.SliceCount,
      _o.Rot);
  }
};

public class PencilShapeT
{
  [Newtonsoft.Json.JsonProperty("pos")]
  public gfl.math.fb.Vector3fT Pos { get; set; }
  [Newtonsoft.Json.JsonProperty("radius")]
  public float Radius { get; set; }
  [Newtonsoft.Json.JsonProperty("cylinderHeight")]
  public float CylinderHeight { get; set; }
  [Newtonsoft.Json.JsonProperty("tipHeight")]
  public float TipHeight { get; set; }
  [Newtonsoft.Json.JsonProperty("sliceCount")]
  public int SliceCount { get; set; }
  [Newtonsoft.Json.JsonProperty("rot")]
  public gfl.math.fb.Vector3fT Rot { get; set; }

  public PencilShapeT() {
    this.Pos = new gfl.math.fb.Vector3fT();
    this.Radius = 0.0f;
    this.CylinderHeight = 0.0f;
    this.TipHeight = 0.0f;
    this.SliceCount = 0;
    this.Rot = new gfl.math.fb.Vector3fT();
  }
}

public struct CollisionShape : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static CollisionShape GetRootAsCollisionShape(ByteBuffer _bb) { return GetRootAsCollisionShape(_bb, new CollisionShape()); }
  public static CollisionShape GetRootAsCollisionShape(ByteBuffer _bb, CollisionShape obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public CollisionShape __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public gfl.scene.fb.CollisionShapeData DataType { get { int o = __p.__offset(4); return o != 0 ? (gfl.scene.fb.CollisionShapeData)__p.bb.Get(o + __p.bb_pos) : gfl.scene.fb.CollisionShapeData.NONE; } }
  public TTable? Data<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(6); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }

  public static Offset<gfl.scene.fb.CollisionShape> CreateCollisionShape(FlatBufferBuilder builder,
      gfl.scene.fb.CollisionShapeData data_type = gfl.scene.fb.CollisionShapeData.NONE,
      int dataOffset = 0) {
    builder.StartTable(2);
    CollisionShape.AddData(builder, dataOffset);
    CollisionShape.AddDataType(builder, data_type);
    return CollisionShape.EndCollisionShape(builder);
  }

  public static void StartCollisionShape(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddDataType(FlatBufferBuilder builder, gfl.scene.fb.CollisionShapeData dataType) { builder.AddByte(0, (byte)dataType, 0); }
  public static void AddData(FlatBufferBuilder builder, int dataOffset) { builder.AddOffset(1, dataOffset, 0); }
  public static Offset<gfl.scene.fb.CollisionShape> EndCollisionShape(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.scene.fb.CollisionShape>(o);
  }
  public static void FinishCollisionShapeBuffer(FlatBufferBuilder builder, Offset<gfl.scene.fb.CollisionShape> offset) { builder.Finish(offset.Value); }
  public static void FinishSizePrefixedCollisionShapeBuffer(FlatBufferBuilder builder, Offset<gfl.scene.fb.CollisionShape> offset) { builder.FinishSizePrefixed(offset.Value); }
  public CollisionShapeT UnPack() {
    var _o = new CollisionShapeT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(CollisionShapeT _o) {
    _o.Data = new gfl.scene.fb.CollisionShapeDataUnion();
    _o.Data.Type = this.DataType;
    switch (this.DataType) {
      default: break;
      case gfl.scene.fb.CollisionShapeData.SphereShape:
        _o.Data.Value = this.Data<gfl.scene.fb.SphereShape>().HasValue ? this.Data<gfl.scene.fb.SphereShape>().Value.UnPack() : null;
        break;
      case gfl.scene.fb.CollisionShapeData.BoxShape:
        _o.Data.Value = this.Data<gfl.scene.fb.BoxShape>().HasValue ? this.Data<gfl.scene.fb.BoxShape>().Value.UnPack() : null;
        break;
      case gfl.scene.fb.CollisionShapeData.CapsuleShape:
        _o.Data.Value = this.Data<gfl.scene.fb.CapsuleShape>().HasValue ? this.Data<gfl.scene.fb.CapsuleShape>().Value.UnPack() : null;
        break;
      case gfl.scene.fb.CollisionShapeData.ModelShape:
        _o.Data.Value = this.Data<gfl.scene.fb.ModelShape>().HasValue ? this.Data<gfl.scene.fb.ModelShape>().Value.UnPack() : null;
        break;
      case gfl.scene.fb.CollisionShapeData.CompoundShape:
        _o.Data.Value = this.Data<gfl.scene.fb.CompoundShape>().HasValue ? this.Data<gfl.scene.fb.CompoundShape>().Value.UnPack() : null;
        break;
      case gfl.scene.fb.CollisionShapeData.PencilShape:
        _o.Data.Value = this.Data<gfl.scene.fb.PencilShape>().HasValue ? this.Data<gfl.scene.fb.PencilShape>().Value.UnPack() : null;
        break;
    }
  }
  public static Offset<gfl.scene.fb.CollisionShape> Pack(FlatBufferBuilder builder, CollisionShapeT _o) {
    if (_o == null) return default(Offset<gfl.scene.fb.CollisionShape>);
    var _data_type = _o.Data == null ? gfl.scene.fb.CollisionShapeData.NONE : _o.Data.Type;
    var _data = _o.Data == null ? 0 : gfl.scene.fb.CollisionShapeDataUnion.Pack(builder, _o.Data);
    return CreateCollisionShape(
      builder,
      _data_type,
      _data);
  }
};

public class CollisionShapeT
{
  [Newtonsoft.Json.JsonProperty("data_type")]
  private gfl.scene.fb.CollisionShapeData DataType {
    get {
      return this.Data != null ? this.Data.Type : gfl.scene.fb.CollisionShapeData.NONE;
    }
    set {
      this.Data = new gfl.scene.fb.CollisionShapeDataUnion();
      this.Data.Type = value;
    }
  }
  [Newtonsoft.Json.JsonProperty("data")]
  [Newtonsoft.Json.JsonConverter(typeof(gfl.scene.fb.CollisionShapeDataUnion_JsonConverter))]
  public gfl.scene.fb.CollisionShapeDataUnion Data { get; set; }

  public CollisionShapeT() {
    this.Data = null;
  }

  public static CollisionShapeT DeserializeFromJson(string jsonText) {
    return Newtonsoft.Json.JsonConvert.DeserializeObject<CollisionShapeT>(jsonText);
  }
  public string SerializeToJson() {
    return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
  }
  public static CollisionShapeT DeserializeFromBinary(byte[] fbBuffer) {
    return CollisionShape.GetRootAsCollisionShape(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    CollisionShape.FinishCollisionShapeBuffer(fbb, CollisionShape.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


}
