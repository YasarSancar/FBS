// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace gfl.scene.fb
{

using global::System;
using global::System.Collections.Generic;
using global::FlatBuffers;

public struct TrSceneChunk : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static TrSceneChunk GetRootAsTrSceneChunk(ByteBuffer _bb) { return GetRootAsTrSceneChunk(_bb, new TrSceneChunk()); }
  public static TrSceneChunk GetRootAsTrSceneChunk(ByteBuffer _bb, TrSceneChunk obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public TrSceneChunk __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Type { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTypeBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetTypeBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetTypeArray() { return __p.__vector_as_array<byte>(4); }
  public byte Data(int j) { int o = __p.__offset(6); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int DataLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDataBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetDataBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetDataArray() { return __p.__vector_as_array<byte>(6); }
  public gfl.scene.fb.TrSceneChunk? Children(int j) { int o = __p.__offset(8); return o != 0 ? (gfl.scene.fb.TrSceneChunk?)(new gfl.scene.fb.TrSceneChunk()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int ChildrenLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<gfl.scene.fb.TrSceneChunk> CreateTrSceneChunk(FlatBufferBuilder builder,
      StringOffset typeOffset = default(StringOffset),
      VectorOffset dataOffset = default(VectorOffset),
      VectorOffset childrenOffset = default(VectorOffset)) {
    builder.StartTable(3);
    TrSceneChunk.AddChildren(builder, childrenOffset);
    TrSceneChunk.AddData(builder, dataOffset);
    TrSceneChunk.AddType(builder, typeOffset);
    return TrSceneChunk.EndTrSceneChunk(builder);
  }

  public static void StartTrSceneChunk(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddType(FlatBufferBuilder builder, StringOffset typeOffset) { builder.AddOffset(0, typeOffset.Value, 0); }
  public static void AddData(FlatBufferBuilder builder, VectorOffset dataOffset) { builder.AddOffset(1, dataOffset.Value, 0); }
  public static VectorOffset CreateDataVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateDataVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static void StartDataVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddChildren(FlatBufferBuilder builder, VectorOffset childrenOffset) { builder.AddOffset(2, childrenOffset.Value, 0); }
  public static VectorOffset CreateChildrenVector(FlatBufferBuilder builder, Offset<gfl.scene.fb.TrSceneChunk>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateChildrenVectorBlock(FlatBufferBuilder builder, Offset<gfl.scene.fb.TrSceneChunk>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartChildrenVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<gfl.scene.fb.TrSceneChunk> EndTrSceneChunk(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.scene.fb.TrSceneChunk>(o);
  }
  public TrSceneChunkT UnPack() {
    var _o = new TrSceneChunkT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(TrSceneChunkT _o) {
    _o.Type = this.Type;
    _o.Data = new List<byte>();
    for (var _j = 0; _j < this.DataLength; ++_j) {_o.Data.Add(this.Data(_j));}
    _o.Children = new List<gfl.scene.fb.TrSceneChunkT>();
    for (var _j = 0; _j < this.ChildrenLength; ++_j) {_o.Children.Add(this.Children(_j).HasValue ? this.Children(_j).Value.UnPack() : null);}
  }
  public static Offset<gfl.scene.fb.TrSceneChunk> Pack(FlatBufferBuilder builder, TrSceneChunkT _o) {
    if (_o == null) return default(Offset<gfl.scene.fb.TrSceneChunk>);
    var _type = _o.Type == null ? default(StringOffset) : builder.CreateString(_o.Type);
    var _data = default(VectorOffset);
    if (_o.Data != null) {
      var __data = _o.Data.ToArray();
      _data = CreateDataVector(builder, __data);
    }
    var _children = default(VectorOffset);
    if (_o.Children != null) {
      var __children = new Offset<gfl.scene.fb.TrSceneChunk>[_o.Children.Count];
      for (var _j = 0; _j < __children.Length; ++_j) { __children[_j] = gfl.scene.fb.TrSceneChunk.Pack(builder, _o.Children[_j]); }
      _children = CreateChildrenVector(builder, __children);
    }
    return CreateTrSceneChunk(
      builder,
      _type,
      _data,
      _children);
  }
};

public class TrSceneChunkT
{
  [Newtonsoft.Json.JsonProperty("type")]
  public string Type { get; set; }
  [Newtonsoft.Json.JsonProperty("data")]
  public List<byte> Data { get; set; }
  [Newtonsoft.Json.JsonProperty("children")]
  public List<gfl.scene.fb.TrSceneChunkT> Children { get; set; }

  public TrSceneChunkT() {
    this.Type = null;
    this.Data = null;
    this.Children = null;
  }
}

public struct TrScene : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static TrScene GetRootAsTrScene(ByteBuffer _bb) { return GetRootAsTrScene(_bb, new TrScene()); }
  public static TrScene GetRootAsTrScene(ByteBuffer _bb, TrScene obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public TrScene __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Name { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(4); }
  public string TimerLevelName { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTimerLevelNameBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetTimerLevelNameBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetTimerLevelNameArray() { return __p.__vector_as_array<byte>(6); }
  public string ScriptPath { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetScriptPathBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetScriptPathBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetScriptPathArray() { return __p.__vector_as_array<byte>(8); }
  public string ScriptPackageName { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetScriptPackageNameBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetScriptPackageNameBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetScriptPackageNameArray() { return __p.__vector_as_array<byte>(10); }
  public gfl.scene.fb.TrSceneChunk? Chunk(int j) { int o = __p.__offset(12); return o != 0 ? (gfl.scene.fb.TrSceneChunk?)(new gfl.scene.fb.TrSceneChunk()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int ChunkLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }
  public string SubScene(int j) { int o = __p.__offset(14); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int SubSceneLength { get { int o = __p.__offset(14); return o != 0 ? __p.__vector_len(o) : 0; } }
  public bool LoadAtStart { get { int o = __p.__offset(16); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool SkipLoadingWithoutTop { get { int o = __p.__offset(18); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public int MemorySize { get { int o = __p.__offset(20); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<gfl.scene.fb.TrScene> CreateTrScene(FlatBufferBuilder builder,
      StringOffset nameOffset = default(StringOffset),
      StringOffset timerLevelNameOffset = default(StringOffset),
      StringOffset scriptPathOffset = default(StringOffset),
      StringOffset scriptPackageNameOffset = default(StringOffset),
      VectorOffset chunkOffset = default(VectorOffset),
      VectorOffset subSceneOffset = default(VectorOffset),
      bool loadAtStart = false,
      bool skipLoadingWithoutTop = false,
      int memorySize = 0) {
    builder.StartTable(9);
    TrScene.AddMemorySize(builder, memorySize);
    TrScene.AddSubScene(builder, subSceneOffset);
    TrScene.AddChunk(builder, chunkOffset);
    TrScene.AddScriptPackageName(builder, scriptPackageNameOffset);
    TrScene.AddScriptPath(builder, scriptPathOffset);
    TrScene.AddTimerLevelName(builder, timerLevelNameOffset);
    TrScene.AddName(builder, nameOffset);
    TrScene.AddSkipLoadingWithoutTop(builder, skipLoadingWithoutTop);
    TrScene.AddLoadAtStart(builder, loadAtStart);
    return TrScene.EndTrScene(builder);
  }

  public static void StartTrScene(FlatBufferBuilder builder) { builder.StartTable(9); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(0, nameOffset.Value, 0); }
  public static void AddTimerLevelName(FlatBufferBuilder builder, StringOffset timerLevelNameOffset) { builder.AddOffset(1, timerLevelNameOffset.Value, 0); }
  public static void AddScriptPath(FlatBufferBuilder builder, StringOffset scriptPathOffset) { builder.AddOffset(2, scriptPathOffset.Value, 0); }
  public static void AddScriptPackageName(FlatBufferBuilder builder, StringOffset scriptPackageNameOffset) { builder.AddOffset(3, scriptPackageNameOffset.Value, 0); }
  public static void AddChunk(FlatBufferBuilder builder, VectorOffset chunkOffset) { builder.AddOffset(4, chunkOffset.Value, 0); }
  public static VectorOffset CreateChunkVector(FlatBufferBuilder builder, Offset<gfl.scene.fb.TrSceneChunk>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateChunkVectorBlock(FlatBufferBuilder builder, Offset<gfl.scene.fb.TrSceneChunk>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartChunkVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddSubScene(FlatBufferBuilder builder, VectorOffset subSceneOffset) { builder.AddOffset(5, subSceneOffset.Value, 0); }
  public static VectorOffset CreateSubSceneVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateSubSceneVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartSubSceneVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddLoadAtStart(FlatBufferBuilder builder, bool loadAtStart) { builder.AddBool(6, loadAtStart, false); }
  public static void AddSkipLoadingWithoutTop(FlatBufferBuilder builder, bool skipLoadingWithoutTop) { builder.AddBool(7, skipLoadingWithoutTop, false); }
  public static void AddMemorySize(FlatBufferBuilder builder, int memorySize) { builder.AddInt(8, memorySize, 0); }
  public static Offset<gfl.scene.fb.TrScene> EndTrScene(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<gfl.scene.fb.TrScene>(o);
  }
  public static void FinishTrSceneBuffer(FlatBufferBuilder builder, Offset<gfl.scene.fb.TrScene> offset) { builder.Finish(offset.Value); }
  public static void FinishSizePrefixedTrSceneBuffer(FlatBufferBuilder builder, Offset<gfl.scene.fb.TrScene> offset) { builder.FinishSizePrefixed(offset.Value); }
  public TrSceneT UnPack() {
    var _o = new TrSceneT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(TrSceneT _o) {
    _o.Name = this.Name;
    _o.TimerLevelName = this.TimerLevelName;
    _o.ScriptPath = this.ScriptPath;
    _o.ScriptPackageName = this.ScriptPackageName;
    _o.Chunk = new List<gfl.scene.fb.TrSceneChunkT>();
    for (var _j = 0; _j < this.ChunkLength; ++_j) {_o.Chunk.Add(this.Chunk(_j).HasValue ? this.Chunk(_j).Value.UnPack() : null);}
    _o.SubScene = new List<string>();
    for (var _j = 0; _j < this.SubSceneLength; ++_j) {_o.SubScene.Add(this.SubScene(_j));}
    _o.LoadAtStart = this.LoadAtStart;
    _o.SkipLoadingWithoutTop = this.SkipLoadingWithoutTop;
    _o.MemorySize = this.MemorySize;
  }
  public static Offset<gfl.scene.fb.TrScene> Pack(FlatBufferBuilder builder, TrSceneT _o) {
    if (_o == null) return default(Offset<gfl.scene.fb.TrScene>);
    var _name = _o.Name == null ? default(StringOffset) : builder.CreateString(_o.Name);
    var _timerLevelName = _o.TimerLevelName == null ? default(StringOffset) : builder.CreateString(_o.TimerLevelName);
    var _scriptPath = _o.ScriptPath == null ? default(StringOffset) : builder.CreateString(_o.ScriptPath);
    var _scriptPackageName = _o.ScriptPackageName == null ? default(StringOffset) : builder.CreateString(_o.ScriptPackageName);
    var _chunk = default(VectorOffset);
    if (_o.Chunk != null) {
      var __chunk = new Offset<gfl.scene.fb.TrSceneChunk>[_o.Chunk.Count];
      for (var _j = 0; _j < __chunk.Length; ++_j) { __chunk[_j] = gfl.scene.fb.TrSceneChunk.Pack(builder, _o.Chunk[_j]); }
      _chunk = CreateChunkVector(builder, __chunk);
    }
    var _subScene = default(VectorOffset);
    if (_o.SubScene != null) {
      var __subScene = new StringOffset[_o.SubScene.Count];
      for (var _j = 0; _j < __subScene.Length; ++_j) { __subScene[_j] = builder.CreateString(_o.SubScene[_j]); }
      _subScene = CreateSubSceneVector(builder, __subScene);
    }
    return CreateTrScene(
      builder,
      _name,
      _timerLevelName,
      _scriptPath,
      _scriptPackageName,
      _chunk,
      _subScene,
      _o.LoadAtStart,
      _o.SkipLoadingWithoutTop,
      _o.MemorySize);
  }
};

public class TrSceneT
{
  [Newtonsoft.Json.JsonProperty("name")]
  public string Name { get; set; }
  [Newtonsoft.Json.JsonProperty("timerLevelName")]
  public string TimerLevelName { get; set; }
  [Newtonsoft.Json.JsonProperty("scriptPath")]
  public string ScriptPath { get; set; }
  [Newtonsoft.Json.JsonProperty("scriptPackageName")]
  public string ScriptPackageName { get; set; }
  [Newtonsoft.Json.JsonProperty("chunk")]
  public List<gfl.scene.fb.TrSceneChunkT> Chunk { get; set; }
  [Newtonsoft.Json.JsonProperty("subScene")]
  public List<string> SubScene { get; set; }
  [Newtonsoft.Json.JsonProperty("loadAtStart")]
  public bool LoadAtStart { get; set; }
  [Newtonsoft.Json.JsonProperty("skipLoadingWithoutTop")]
  public bool SkipLoadingWithoutTop { get; set; }
  [Newtonsoft.Json.JsonProperty("memorySize")]
  public int MemorySize { get; set; }

  public TrSceneT() {
    this.Name = null;
    this.TimerLevelName = null;
    this.ScriptPath = null;
    this.ScriptPackageName = null;
    this.Chunk = null;
    this.SubScene = null;
    this.LoadAtStart = false;
    this.SkipLoadingWithoutTop = false;
    this.MemorySize = 0;
  }

  public static TrSceneT DeserializeFromJson(string jsonText) {
    return Newtonsoft.Json.JsonConvert.DeserializeObject<TrSceneT>(jsonText);
  }
  public string SerializeToJson() {
    return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
  }
  public static TrSceneT DeserializeFromBinary(byte[] fbBuffer) {
    return TrScene.GetRootAsTrScene(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    TrScene.FinishTrSceneBuffer(fbb, TrScene.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


}
